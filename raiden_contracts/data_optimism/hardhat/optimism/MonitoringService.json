{
  "address": "0xE37d878e97ec516225dC151f4A056e23460e177D",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_token_address",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_service_registry_address",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_udc_address",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_token_network_registry_address",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "token_network_address",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "channel_identifier",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "reward_amount",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "nonce",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "ms_address",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "raiden_node_address",
          "type": "address"
        }
      ],
      "name": "NewBalanceProofReceived",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "ms_address",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "reward_identifier",
          "type": "bytes32"
        }
      ],
      "name": "RewardClaimed",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "channel_identifier",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "token_network_address",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "closing_participant",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "non_closing_participant",
          "type": "address"
        }
      ],
      "name": "claimReward",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "contract_address",
          "type": "address"
        }
      ],
      "name": "contractExists",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "closed_at_block",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "settle_timeout",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "participant1",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "participant2",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "monitoring_service_address",
          "type": "address"
        }
      ],
      "name": "firstBlockAllowedToMonitor",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract TokenNetwork",
          "name": "token_network",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "channel_identifier",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "closing_participant",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "non_closing_participant",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "monitoring_service_address",
          "type": "address"
        }
      ],
      "name": "firstBlockAllowedToMonitorChannel",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "closing_participant",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "non_closing_participant",
          "type": "address"
        },
        {
          "internalType": "bytes32",
          "name": "balance_hash",
          "type": "bytes32"
        },
        {
          "internalType": "uint256",
          "name": "nonce",
          "type": "uint256"
        },
        {
          "internalType": "bytes32",
          "name": "additional_hash",
          "type": "bytes32"
        },
        {
          "internalType": "bytes",
          "name": "closing_signature",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "non_closing_signature",
          "type": "bytes"
        },
        {
          "internalType": "uint256",
          "name": "reward_amount",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "token_network_address",
          "type": "address"
        },
        {
          "internalType": "bytes",
          "name": "reward_proof_signature",
          "type": "bytes"
        }
      ],
      "name": "monitor",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "service_registry",
      "outputs": [
        {
          "internalType": "contract ServiceRegistry",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "token",
      "outputs": [
        {
          "internalType": "contract Token",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "token_network_registry",
      "outputs": [
        {
          "internalType": "contract TokenNetworkRegistry",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "user_deposit",
      "outputs": [
        {
          "internalType": "contract UserDeposit",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0xf89f317d4e1203a609b7049d2f6f93de2127315e6e047953b05c959748a37eda",
  "receipt": {
    "to": null,
    "from": "0xFb8C3ba8A46014400487f2fB4d539A5Ff7bC367D",
    "contractAddress": "0xE37d878e97ec516225dC151f4A056e23460e177D",
    "transactionIndex": 0,
    "gasUsed": "3519425",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000040000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000008000000400000000010000000000000000000000400000000000000000000000000008000000200000000000000000010000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000040000000000000000000",
    "blockHash": "0xba614a2608e09451a26a992d312086aae12ad001cf0cdf41d754239e6c540386",
    "transactionHash": "0xf89f317d4e1203a609b7049d2f6f93de2127315e6e047953b05c959748a37eda",
    "logs": [
      {
        "transactionIndex": 0,
        "blockNumber": 115435,
        "transactionHash": "0xf89f317d4e1203a609b7049d2f6f93de2127315e6e047953b05c959748a37eda",
        "address": "0x4200000000000000000000000000000000000006",
        "topics": [
          "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
          "0x000000000000000000000000fb8c3ba8a46014400487f2fb4d539a5ff7bc367d",
          "0x0000000000000000000000004200000000000000000000000000000000000005"
        ],
        "data": "0x0000000000000000000000000000000000000000000000000000000000000000",
        "logIndex": 0,
        "blockHash": "0xba614a2608e09451a26a992d312086aae12ad001cf0cdf41d754239e6c540386"
      }
    ],
    "blockNumber": 115435,
    "cumulativeGasUsed": "3519425",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0x806E55Dc852609176F187a5C515393C923179d0C",
    "0x9b4d7E59f6cA64f37864845966E106cfbe6Eaa10",
    "0xc3Fbcb0aADdFE6399e04fCADa42F92C9104Cb133",
    "0xEBD114D78aCe713DBA75e649eb763Eb9A4DeddaA"
  ],
  "solcInputHash": "d801cd5192b29c16d8f34c547e4f6dd2",
  "metadata": "{\"compiler\":{\"version\":\"0.7.6+ovm+commit.aff196a1\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token_address\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_service_registry_address\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_udc_address\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token_network_registry_address\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token_network_address\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"channel_identifier\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward_amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"ms_address\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"raiden_node_address\",\"type\":\"address\"}],\"name\":\"NewBalanceProofReceived\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"ms_address\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"reward_identifier\",\"type\":\"bytes32\"}],\"name\":\"RewardClaimed\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"channel_identifier\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token_network_address\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"closing_participant\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"non_closing_participant\",\"type\":\"address\"}],\"name\":\"claimReward\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contract_address\",\"type\":\"address\"}],\"name\":\"contractExists\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"closed_at_block\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"settle_timeout\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"participant1\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"participant2\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"monitoring_service_address\",\"type\":\"address\"}],\"name\":\"firstBlockAllowedToMonitor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract TokenNetwork\",\"name\":\"token_network\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"channel_identifier\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"closing_participant\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"non_closing_participant\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"monitoring_service_address\",\"type\":\"address\"}],\"name\":\"firstBlockAllowedToMonitorChannel\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"closing_participant\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"non_closing_participant\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"balance_hash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"additional_hash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"closing_signature\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"non_closing_signature\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"reward_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token_network_address\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"reward_proof_signature\",\"type\":\"bytes\"}],\"name\":\"monitor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"service_registry\",\"outputs\":[{\"internalType\":\"contract ServiceRegistry\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract Token\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token_network_registry\",\"outputs\":[{\"internalType\":\"contract TokenNetworkRegistry\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"user_deposit\",\"outputs\":[{\"internalType\":\"contract UserDeposit\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"claimReward(uint256,address,address,address)\":{\"params\":{\"closing_participant\":\"Address of the participant of the channel that called close\",\"non_closing_participant\":\"The other participant of the channel\",\"token_network_address\":\"Address of the Token Network in which the channel exists\"}},\"constructor\":{\"params\":{\"_service_registry_address\":\"The address of the ServiceRegistry contract\",\"_token_address\":\"The address of the token to use for rewards\",\"_token_network_registry_address\":\"The address of the TokenNetworkRegistry for authenticating TokenNetworks\"}},\"contractExists(address)\":{\"params\":{\"contract_address\":\"The address to check whether a contract is deployed or not\"},\"returns\":{\"_0\":\"True if a contract exists, false otherwise\"}},\"monitor(address,address,bytes32,uint256,bytes32,bytes,bytes,uint256,address,bytes)\":{\"params\":{\"nonce\":\"Strictly monotonic value used to order BPs omitting PB specific params, since these will not be provided in the future\",\"reward_amount\":\"Amount of tokens to be rewarded\",\"reward_proof_signature\":\"The signature of the signed reward proof\",\"token_network_address\":\"Address of the Token Network in which the channel being monitored exists.\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"claimReward(uint256,address,address,address)\":{\"notice\":\"Called after a monitored channel is settled in order for MS to claim the reward Can be called once per settled channel by everyone on behalf of MS\"},\"constructor\":{\"notice\":\"Set the default values for the smart contract\"},\"contractExists(address)\":{\"notice\":\"Check if a contract exists\"},\"monitor(address,address,bytes32,uint256,bytes32,bytes,bytes,uint256,address,bytes)\":{\"notice\":\"Called by a registered MS, when providing a new balance proof to a monitored channel. Can be called multiple times by different registered MSs as long as the BP provided is newer than the current newest registered BP.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"data/source/services/MonitoringService.sol\":\"MonitoringService\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":1},\"remappings\":[]},\"sources\":{\"data/source/lib/ECVerify.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n/* solium-disable error-reason */\\npragma solidity 0.7.6;\\n\\nlibrary ECVerify {\\n\\n    function ecverify(bytes32 hash, bytes memory signature)\\n        internal\\n        pure\\n        returns (address signature_address)\\n    {\\n        require(signature.length == 65);\\n\\n        bytes32 r;\\n        bytes32 s;\\n        uint8 v;\\n\\n        // The signature format is a compact form of:\\n        //   {bytes32 r}{bytes32 s}{uint8 v}\\n        // Compact means, uint8 is not padded to 32 bytes.\\n        assembly { // solium-disable-line security/no-inline-assembly\\n            r := mload(add(signature, 32))\\n            s := mload(add(signature, 64))\\n\\n            // Here we are loading the last 32 bytes, including 31 bytes following the signature.\\n            v := byte(0, mload(add(signature, 96)))\\n        }\\n\\n        // Version of signature should be 27 or 28, but 0 and 1 are also possible\\n        if (v < 27) {\\n            v += 27;\\n        }\\n\\n        require(v == 27 || v == 28);\\n\\n        signature_address = ecrecover(hash, v, r, s);\\n\\n        // ecrecover returns zero on error\\n        require(signature_address != address(0x0));\\n\\n        return signature_address;\\n    }\\n}\\n\",\"keccak256\":\"0xeced41e7578af77042e00fc68e482b754cd355da872bfdda95a0b74e3dbd90e0\",\"license\":\"MIT\"},\"data/source/lib/MessageType.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n/* solium-disable error-reason */\\npragma solidity 0.7.6;\\n\\nlibrary MessageType {\\n\\n    enum MessageTypeId {\\n        None,\\n        BalanceProof,\\n        BalanceProofUpdate,\\n        Withdraw,\\n        CooperativeSettle,\\n        IOU,\\n        MSReward\\n    }\\n}\\n\",\"keccak256\":\"0xe4a3d54220ba19024c03fac9f8b3338245f2c4aa266627e6cdb5e97a2adcdee4\",\"license\":\"MIT\"},\"data/source/lib/TokenNetworkUtils.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n/* solium-disable indentation */\\npragma solidity 0.7.6;\\n\\nimport \\\"./ECVerify.sol\\\";\\nimport \\\"./MessageType.sol\\\";\\n\\nlibrary TokenNetworkUtils {\\n    string internal constant signature_prefix = \\\"\\\\x19Ethereum Signed Message:\\\\n\\\";\\n\\n    function getMaxPossibleReceivableAmount(\\n        uint256 participant1_deposit,\\n        uint256 participant1_withdrawn,\\n        uint256 participant1_transferred,\\n        uint256 participant1_locked,\\n        uint256 participant2_deposit,\\n        uint256 participant2_withdrawn,\\n        uint256 participant2_transferred,\\n        uint256 participant2_locked\\n    )\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        uint256 participant1_max_transferred;\\n        uint256 participant2_max_transferred;\\n        uint256 participant1_net_max_received;\\n        uint256 participant1_max_amount;\\n\\n        // This is the maximum possible amount that participant1 could transfer\\n        // to participant2, if all the pending lock secrets have been\\n        // registered\\n        participant1_max_transferred = failsafe_addition(\\n            participant1_transferred,\\n            participant1_locked\\n        );\\n\\n        // This is the maximum possible amount that participant2 could transfer\\n        // to participant1, if all the pending lock secrets have been\\n        // registered\\n        participant2_max_transferred = failsafe_addition(\\n            participant2_transferred,\\n            participant2_locked\\n        );\\n\\n        // We enforce this check artificially, in order to get rid of hard\\n        // to deal with over/underflows. Settlement balance calculation is\\n        // symmetric (we can calculate either RmaxP1 and RmaxP2 first, order does\\n        // not affect result). This means settleChannel must be called with\\n        // ordered values.\\n        require(participant2_max_transferred >= participant1_max_transferred, \\\"TNU: transfers not ordered\\\");\\n\\n        assert(participant1_max_transferred >= participant1_transferred);\\n        assert(participant2_max_transferred >= participant2_transferred);\\n\\n        // This is the maximum amount that participant1 can receive at settlement time\\n        participant1_net_max_received = (\\n            participant2_max_transferred -\\n            participant1_max_transferred\\n        );\\n\\n        // Next, we add the participant1's deposit and subtract the already\\n        // withdrawn amount\\n        participant1_max_amount = failsafe_addition(\\n            participant1_net_max_received,\\n            participant1_deposit\\n        );\\n\\n        // Subtract already withdrawn amount\\n        (participant1_max_amount, ) = failsafe_subtract(\\n            participant1_max_amount,\\n            participant1_withdrawn\\n        );\\n        return participant1_max_amount;\\n    }\\n\\n    function min(uint256 a, uint256 b) internal pure returns (uint256)\\n    {\\n        return a > b ? b : a;\\n    }\\n\\n    function max(uint256 a, uint256 b) internal pure returns (uint256)\\n    {\\n        return a > b ? a : b;\\n    }\\n\\n    /// @dev Special subtraction function that does not fail when underflowing.\\n    /// @param a Minuend\\n    /// @param b Subtrahend\\n    /// @return Minimum between the result of the subtraction and 0, the maximum\\n    /// subtrahend for which no underflow occurs\\n    function failsafe_subtract(uint256 a, uint256 b)\\n        internal\\n        pure\\n        returns (uint256, uint256)\\n    {\\n        return a > b ? (a - b, b) : (0, a);\\n    }\\n\\n    /// @dev Special addition function that does not fail when overflowing.\\n    /// @param a Addend\\n    /// @param b Addend\\n    /// @return Maximum between the result of the addition or the maximum\\n    /// uint256 value\\n    function failsafe_addition(uint256 a, uint256 b)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        uint256 MAX_SAFE_UINT256 = (\\n            115792089237316195423570985008687907853269984665640564039457584007913129639935\\n        );\\n        uint256 sum = a + b;\\n        return sum >= a ? sum : MAX_SAFE_UINT256;\\n    }\\n\\n    function recoverAddressFromBalanceProof(\\n        uint256 chain_id,\\n        uint256 channel_identifier,\\n        bytes32 balance_hash,\\n        uint256 nonce,\\n        bytes32 additional_hash,\\n        bytes memory signature\\n    )\\n        internal\\n        view\\n        returns (address signature_address)\\n    {\\n        // Length of the actual message: 20 + 32 + 32 + 32 + 32 + 32 + 32\\n        string memory message_length = \\\"212\\\";\\n\\n        bytes32 message_hash = keccak256(abi.encodePacked(\\n            signature_prefix,\\n            message_length,\\n            address(this),\\n            chain_id,\\n            uint256(MessageType.MessageTypeId.BalanceProof),\\n            channel_identifier,\\n            balance_hash,\\n            nonce,\\n            additional_hash\\n        ));\\n\\n        signature_address = ECVerify.ecverify(message_hash, signature);\\n    }\\n\\n    function recoverAddressFromBalanceProofCounterSignature(\\n        MessageType.MessageTypeId message_type_id,\\n        uint256 chain_id,\\n        uint256 channel_identifier,\\n        bytes32 balance_hash,\\n        uint256 nonce,\\n        bytes32 additional_hash,\\n        bytes memory closing_signature,\\n        bytes memory non_closing_signature\\n    )\\n        internal\\n        view\\n        returns (address signature_address)\\n    {\\n        // Length of the actual message: 20 + 32 + 32 + 32 + 32 + 32 + 32 + 65\\n        string memory message_length = \\\"277\\\";\\n\\n        bytes32 message_hash = keccak256(abi.encodePacked(\\n            signature_prefix,\\n            message_length,\\n            address(this),\\n            chain_id,\\n            uint256(message_type_id),\\n            channel_identifier,\\n            balance_hash,\\n            nonce,\\n            additional_hash,\\n            closing_signature\\n        ));\\n\\n        signature_address = ECVerify.ecverify(message_hash, non_closing_signature);\\n    }\\n\\n    /* function recoverAddressFromCooperativeSettleSignature(\\n        uint256 channel_identifier,\\n        address participant1,\\n        uint256 participant1_balance,\\n        address participant2,\\n        uint256 participant2_balance,\\n        bytes signature\\n    )\\n        view\\n        internal\\n        returns (address signature_address)\\n    {\\n        // Length of the actual message: 20 + 32 + 32 + 32 + 20 + 32 + 20 + 32\\n        string memory message_length = '220';\\n\\n        bytes32 message_hash = keccak256(abi.encodePacked(\\n            signature_prefix,\\n            message_length,\\n            address(this),\\n            chain_id,\\n            uint256(MessageTypeId.CooperativeSettle),\\n            channel_identifier,\\n            participant1,\\n            participant1_balance,\\n            participant2,\\n            participant2_balance\\n        ));\\n\\n        signature_address = ECVerify.ecverify(message_hash, signature);\\n    } */\\n\\n    function recoverAddressFromWithdrawMessage(\\n        uint256 chain_id,\\n        uint256 channel_identifier,\\n        address participant,\\n        uint256 total_withdraw,\\n        uint256 expiration_block,\\n        bytes memory signature\\n    )\\n        internal\\n        view\\n        returns (address signature_address)\\n    {\\n        // Length of the actual message: 20 + 32 + 32 + 32 + 20 + 32 + 32\\n        string memory message_length = \\\"200\\\";\\n\\n        bytes32 message_hash = keccak256(abi.encodePacked(\\n            signature_prefix,\\n            message_length,\\n            address(this),\\n            chain_id,\\n            uint256(MessageType.MessageTypeId.Withdraw),\\n            channel_identifier,\\n            participant,\\n            total_withdraw,\\n            expiration_block\\n        ));\\n\\n        signature_address = ECVerify.ecverify(message_hash, signature);\\n    }\\n}\\n\",\"keccak256\":\"0x115640f1f605878e1d55e5e5e3c3e0f24e55eb435d8e618405d4bf2f14a99f59\",\"license\":\"MIT\"},\"data/source/raiden/SecretRegistry.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.6;\\n\\n/// @title SecretRegistry\\n/// @notice SecretRegistry contract for registering secrets from Raiden Network\\n/// clients.\\ncontract SecretRegistry {\\n    // sha256(secret) => block number at which the secret was revealed\\n    mapping(bytes32 => uint256) private secrethash_to_block;\\n\\n    event SecretRevealed(bytes32 indexed secrethash, bytes32 secret);\\n\\n    /// @notice Registers a hash time lock secret and saves the block number.\\n    /// This allows the lock to be unlocked after the expiration block\\n    /// @param secret The secret used to lock the hash time lock\\n    /// @return true if secret was registered, false if the secret was already\\n    /// registered\\n    function registerSecret(bytes32 secret) public returns (bool) {\\n        bytes32 secrethash = sha256(abi.encodePacked(secret));\\n        if (secrethash_to_block[secrethash] > 0) {\\n            return false;\\n        }\\n        secrethash_to_block[secrethash] = block.number;\\n        emit SecretRevealed(secrethash, secret);\\n        return true;\\n    }\\n\\n    /// @notice Registers multiple hash time lock secrets and saves the block\\n    /// number\\n    /// @param secrets The array of secrets to be registered\\n    /// @return true if all secrets could be registered, false otherwise\\n    function registerSecretBatch(bytes32[] memory secrets) public returns (bool) {\\n        bool completeSuccess = true;\\n        for(uint i = 0; i < secrets.length; i++) {\\n            if(!registerSecret(secrets[i])) {\\n                completeSuccess = false;\\n            }\\n        }\\n        return completeSuccess;\\n    }\\n\\n    /// @notice Get the stored block number at which the secret was revealed\\n    /// @param secrethash The hash of the registered secret `keccak256(secret)`\\n    /// @return The block number at which the secret was revealed\\n    function getSecretRevealBlockHeight(bytes32 secrethash) public view returns (uint256) {\\n        return secrethash_to_block[secrethash];\\n    }\\n}\\n\\n// MIT License\\n\\n// Copyright (c) 2018\\n\\n// Permission is hereby granted, free of charge, to any person obtaining a copy\\n// of this software and associated documentation files (the \\\"Software\\\"), to deal\\n// in the Software without restriction, including without limitation the rights\\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n// copies of the Software, and to permit persons to whom the Software is\\n// furnished to do so, subject to the following conditions:\\n\\n// The above copyright notice and this permission notice shall be included in all\\n// copies or substantial portions of the Software.\\n\\n// THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n// SOFTWARE.\\n\",\"keccak256\":\"0x828dbf9a344f66cb982df97f677d10942d1b163287b890860be40230b236642e\",\"license\":\"MIT\"},\"data/source/raiden/Token.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.6;\\n\\ninterface Token {\\n\\n    /// @return supply total amount of tokens\\n    function totalSupply() external view returns (uint256 supply);\\n\\n    /// @param _owner The address from which the balance will be retrieved\\n    /// @return balance The balance\\n    function balanceOf(address _owner) external view returns (uint256 balance);\\n\\n    /// @notice send `_value` token to `_to` from `msg.sender`\\n    /// @param _to The address of the recipient\\n    /// @param _value The amount of token to be transferred\\n    /// @return success Whether the transfer was successful or not\\n    function transfer(address _to, uint256 _value) external returns (bool success);\\n\\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\\n    /// @param _from The address of the sender\\n    /// @param _to The address of the recipient\\n    /// @param _value The amount of token to be transferred\\n    /// @return success Whether the transfer was successful or not\\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\\n\\n    /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\\n    /// @param _spender The address of the account able to transfer the tokens\\n    /// @param _value The amount of wei to be approved for transfer\\n    /// @return success Whether the approval was successful or not\\n    function approve(address _spender, uint256 _value) external returns (bool success);\\n\\n    /// @param _owner The address of the account owning tokens\\n    /// @param _spender The address of the account able to transfer the tokens\\n    /// @return remaining Amount of remaining tokens allowed to spent\\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining);\\n\\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\\n\\n    // Optionally implemented function to show the number of decimals for the token\\n    function decimals() external view returns (uint8 decimals);\\n}\\n\",\"keccak256\":\"0x5a8ccb9fa426228d9e213164f22a94b0ac57f1aa15ab76ce88a96177edd7b0b3\",\"license\":\"MIT\"},\"data/source/raiden/TokenNetwork.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n/* solium-disable error-reason */\\n/* solium-disable indentation */\\npragma solidity 0.7.6;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../lib/ECVerify.sol\\\";\\nimport \\\"../lib/MessageType.sol\\\";\\nimport \\\"../lib/TokenNetworkUtils.sol\\\";\\nimport \\\"./Token.sol\\\";\\nimport \\\"./Utils.sol\\\";\\nimport \\\"./SecretRegistry.sol\\\";\\n\\n/// @title TokenNetwork\\n/// @notice Stores and manages all the Raiden Network channels that use the\\n/// token specified in this TokenNetwork contract.\\ncontract TokenNetwork is Utils {\\n    // Instance of the token used by the channels\\n    Token public token;\\n\\n    // Instance of SecretRegistry used for storing secrets revealed in a\\n    // mediating transfer.\\n    SecretRegistry public secret_registry;\\n\\n    // Chain ID as specified by EIP155 used in balance proof signatures to\\n    // avoid replay attacks\\n    uint256 public chain_id;\\n\\n    uint256 public settlement_timeout_min;\\n    uint256 public settlement_timeout_max;\\n\\n    uint256 constant public MAX_SAFE_UINT256 = (\\n        115792089237316195423570985008687907853269984665640564039457584007913129639935\\n    );\\n\\n    // The deposit limit per channel per participant.\\n    uint256 public channel_participant_deposit_limit;\\n    // The total combined deposit of all channels across the whole network\\n    uint256 public token_network_deposit_limit;\\n\\n    // Global, monotonically increasing counter that keeps track of all the\\n    // opened channels in this contract\\n    uint256 public channel_counter;\\n\\n    // Only for the limited Red Eyes release\\n    address public deprecation_executor;\\n    bool public safety_deprecation_switch = false;\\n\\n    // channel_identifier => Channel\\n    // channel identifier is the channel_counter value at the time of opening\\n    // the channel\\n    mapping (uint256 => Channel) public channels;\\n\\n    // This is needed to enforce one channel per pair of participants\\n    // The key is keccak256(participant1_address, participant2_address)\\n    mapping (bytes32 => uint256) public participants_hash_to_channel_identifier;\\n\\n    // We keep the unlock data in a separate mapping to allow channel data\\n    // structures to be removed when settling uncooperatively. If there are\\n    // locked pending transfers, we need to store data needed to unlock them at\\n    // a later time.\\n    // The key is `keccak256(uint256 channel_identifier, address participant,\\n    // address partner)` Where `participant` is the participant that sent the\\n    // pending transfers We need `partner` for knowing where to send the\\n    // claimable tokens\\n    mapping(bytes32 => UnlockData) private unlock_identifier_to_unlock_data;\\n\\n    struct Participant {\\n        // Total amount of tokens transferred to this smart contract through\\n        // the `setTotalDeposit` function, for a specific channel, in the\\n        // participant's benefit.\\n        // This is a strictly monotonic value. Note that direct token transfer\\n        // into the contract cannot be tracked and will be stuck.\\n        uint256 deposit;\\n\\n        // Total amount of tokens withdrawn by the participant during the\\n        // lifecycle of this channel.\\n        // This is a strictly monotonic value.\\n        uint256 withdrawn_amount;\\n\\n        // This is a value set to true after the channel has been closed, only\\n        // if this is the participant who closed the channel.\\n        bool is_the_closer;\\n\\n        // keccak256 of the balance data provided after a closeChannel or an\\n        // updateNonClosingBalanceProof call\\n        bytes32 balance_hash;\\n\\n        // Monotonically increasing counter of the off-chain transfers,\\n        // provided along with the balance_hash\\n        uint256 nonce;\\n    }\\n\\n    enum ChannelState {\\n        NonExistent, // 0\\n        Opened,      // 1\\n        Closed,      // 2\\n        Settled,     // 3; Note: The channel has at least one pending unlock\\n        Removed      // 4; Note: Channel data is removed, there are no pending unlocks\\n    }\\n\\n    struct Channel {\\n        // After opening the channel this value represents the settlement\\n        // window. This is the number of blocks that need to be mined between\\n        // closing the channel uncooperatively and settling the channel.\\n        // After the channel has been uncooperatively closed, this value\\n        // represents the block number after which settleChannel can be called.\\n        uint256 settle_block_number;\\n\\n        ChannelState state;\\n\\n        mapping(address => Participant) participants;\\n    }\\n\\n    struct SettlementData {\\n        uint256 deposit;\\n        uint256 withdrawn;\\n        uint256 transferred;\\n        uint256 locked;\\n    }\\n\\n    struct UnlockData {\\n        // keccak256 hash of the pending locks from the Raiden client\\n        bytes32 locksroot;\\n        // Total amount of tokens locked in the pending locks corresponding\\n        // to the `locksroot`\\n        uint256 locked_amount;\\n    }\\n\\n    struct SettleInput {\\n        address participant;\\n        uint256 transferred_amount;\\n        uint256 locked_amount;\\n        bytes32 locksroot;\\n    }\\n\\n    event ChannelOpened(\\n        uint256 indexed channel_identifier,\\n        address indexed participant1,\\n        address indexed participant2,\\n        uint256 settle_timeout\\n    );\\n\\n    event ChannelNewDeposit(\\n        uint256 indexed channel_identifier,\\n        address indexed participant,\\n        uint256 total_deposit\\n    );\\n\\n    // Fires when the deprecation_switch's value changes\\n    event DeprecationSwitch(bool new_value);\\n\\n    // total_withdraw is how much the participant has withdrawn during the\\n    // lifetime of the channel. The actual amount which the participant withdrew\\n    // is `total_withdraw - total_withdraw_from_previous_event_or_zero`\\n    event ChannelWithdraw(\\n        uint256 indexed channel_identifier,\\n        address indexed participant,\\n        uint256 total_withdraw\\n    );\\n\\n    event ChannelClosed(\\n        uint256 indexed channel_identifier,\\n        address indexed closing_participant,\\n        uint256 indexed nonce,\\n        bytes32 balance_hash\\n    );\\n\\n    event ChannelUnlocked(\\n        uint256 indexed channel_identifier,\\n        address indexed receiver,\\n        address indexed sender,\\n        bytes32 locksroot,\\n        uint256 unlocked_amount,\\n        uint256 returned_tokens\\n    );\\n\\n    event NonClosingBalanceProofUpdated(\\n        uint256 indexed channel_identifier,\\n        address indexed closing_participant,\\n        uint256 indexed nonce,\\n        bytes32 balance_hash\\n    );\\n\\n    event ChannelSettled(\\n        uint256 indexed channel_identifier,\\n        uint256 participant1_amount,\\n        bytes32 participant1_locksroot,\\n        uint256 participant2_amount,\\n        bytes32 participant2_locksroot\\n    );\\n\\n    modifier onlyDeprecationExecutor() {\\n        require(msg.sender == deprecation_executor);\\n        _;\\n    }\\n\\n    modifier isSafe() {\\n        require(safety_deprecation_switch == false);\\n        _;\\n    }\\n\\n    modifier isOpen(uint256 channel_identifier) {\\n        require(channels[channel_identifier].state == ChannelState.Opened);\\n        _;\\n    }\\n\\n    modifier settleTimeoutValid(uint256 timeout) {\\n        require(timeout >= settlement_timeout_min);\\n        require(timeout <= settlement_timeout_max);\\n        _;\\n    }\\n\\n    /// @param _token_address The address of the ERC20 token contract\\n    /// @param _secret_registry The address of SecretRegistry contract that witnesses the onchain secret reveals\\n    /// @param _chain_id EIP-155 Chain ID of the blockchain where this instance is being deployed\\n    /// @param _settlement_timeout_min The shortest settlement period (in number of blocks)\\n    /// that can be chosen at the channel opening\\n    /// @param _settlement_timeout_max The longest settlement period (in number of blocks)\\n    /// that can be chosen at the channel opening\\n    /// @param _deprecation_executor The Ethereum address that can disable new deposits and channel creation\\n    /// @param _channel_participant_deposit_limit The maximum amount of tokens that can be deposited by each\\n    /// participant of each channel. MAX_SAFE_UINT256 means no limits\\n    /// @param _token_network_deposit_limit The maximum amount of tokens that this contract can hold\\n    /// MAX_SAFE_UINT256 means no limits\\n    constructor(\\n        address _token_address,\\n        address _secret_registry,\\n        uint256 _chain_id,\\n        uint256 _settlement_timeout_min,\\n        uint256 _settlement_timeout_max,\\n        address _deprecation_executor,\\n        uint256 _channel_participant_deposit_limit,\\n        uint256 _token_network_deposit_limit\\n    ) {\\n        require(_token_address != address(0x0));\\n        require(_secret_registry != address(0x0));\\n        require(_deprecation_executor != address(0x0));\\n        require(_chain_id > 0);\\n        require(_settlement_timeout_min > 0);\\n        require(_settlement_timeout_max > _settlement_timeout_min);\\n        require(contractExists(_token_address));\\n        require(contractExists(_secret_registry));\\n        require(_channel_participant_deposit_limit > 0);\\n        require(_token_network_deposit_limit > 0);\\n        require(_token_network_deposit_limit >= _channel_participant_deposit_limit);\\n\\n        token = Token(_token_address);\\n\\n        secret_registry = SecretRegistry(_secret_registry);\\n        chain_id = _chain_id;\\n        settlement_timeout_min = _settlement_timeout_min;\\n        settlement_timeout_max = _settlement_timeout_max;\\n\\n        // Make sure the contract is indeed a token contract\\n        require(token.totalSupply() > 0);\\n\\n        deprecation_executor = _deprecation_executor;\\n        channel_participant_deposit_limit = _channel_participant_deposit_limit;\\n        token_network_deposit_limit = _token_network_deposit_limit;\\n    }\\n\\n    function deprecate() public isSafe onlyDeprecationExecutor {\\n        safety_deprecation_switch = true;\\n        emit DeprecationSwitch(safety_deprecation_switch);\\n    }\\n\\n    /// @notice Opens a new channel between `participant1` and `participant2`.\\n    /// Can be called by anyone\\n    /// @param participant1 Ethereum address of a channel participant\\n    /// @param participant2 Ethereum address of the other channel participant\\n    /// @param settle_timeout Number of blocks that need to be mined between a\\n    /// call to closeChannel and settleChannel\\n    function openChannel(address participant1, address participant2, uint256 settle_timeout)\\n        public\\n        isSafe\\n        settleTimeoutValid(settle_timeout)\\n        returns (uint256)\\n    {\\n        bytes32 pair_hash;\\n        uint256 channel_identifier;\\n\\n        // Red Eyes release token network limit\\n        require(token.balanceOf(address(this)) < token_network_deposit_limit);\\n\\n        // First increment the counter\\n        // There will never be a channel with channel_identifier == 0\\n        channel_counter += 1;\\n        channel_identifier = channel_counter;\\n\\n        pair_hash = getParticipantsHash(participant1, participant2);\\n\\n        // There must only be one channel opened between two participants at\\n        // any moment in time.\\n        require(participants_hash_to_channel_identifier[pair_hash] == 0);\\n        participants_hash_to_channel_identifier[pair_hash] = channel_identifier;\\n\\n        Channel storage channel = channels[channel_identifier];\\n\\n        // We always increase the channel counter, therefore no channel data can already exist,\\n        // corresponding to this channel_identifier. This check must never fail.\\n        assert(channel.settle_block_number == 0);\\n        assert(channel.state == ChannelState.NonExistent);\\n\\n        // Store channel information\\n        channel.settle_block_number = settle_timeout;\\n        channel.state = ChannelState.Opened;\\n\\n        emit ChannelOpened(\\n            channel_identifier,\\n            participant1,\\n            participant2,\\n            settle_timeout\\n        );\\n\\n        return channel_identifier;\\n    }\\n\\n    /// @notice Sets the channel participant total deposit value.\\n    /// Can be called by anyone.\\n    /// @param channel_identifier Identifier for the channel on which this\\n    /// operation takes place\\n    /// @param participant Channel participant whose deposit is being set\\n    /// @param total_deposit The total amount of tokens that the participant\\n    /// will have as a deposit\\n    /// @param partner Channel partner address, needed to compute the total\\n    /// channel deposit\\n    function setTotalDeposit(\\n        uint256 channel_identifier,\\n        address participant,\\n        uint256 total_deposit,\\n        address partner\\n    )\\n        public\\n        isSafe\\n        isOpen(channel_identifier)\\n    {\\n        require(channel_identifier == getChannelIdentifier(participant, partner));\\n        require(total_deposit > 0);\\n        require(total_deposit <= channel_participant_deposit_limit);\\n\\n        uint256 added_deposit;\\n        uint256 channel_deposit;\\n\\n        Channel storage channel = channels[channel_identifier];\\n        Participant storage participant_state = channel.participants[participant];\\n        Participant storage partner_state = channel.participants[partner];\\n\\n        // Calculate the actual amount of tokens that will be transferred\\n        added_deposit = total_deposit - participant_state.deposit;\\n\\n        // The actual amount of tokens that will be transferred must be > 0\\n        require(added_deposit > 0);\\n\\n        // Underflow check; we use <= because added_deposit == total_deposit for the first deposit\\n\\n        require(added_deposit <= total_deposit);\\n\\n        // This should never fail at this point. Added check for security, because we directly set\\n        // the participant_state.deposit = total_deposit, while we transfer `added_deposit` tokens\\n        assert(participant_state.deposit + added_deposit == total_deposit);\\n\\n        // Red Eyes release token network limit\\n        require(token.balanceOf(address(this)) + added_deposit <= token_network_deposit_limit);\\n\\n        // Update the participant's channel deposit\\n        participant_state.deposit = total_deposit;\\n\\n        // Calculate the entire channel deposit, to avoid overflow\\n        channel_deposit = participant_state.deposit + partner_state.deposit;\\n        // Overflow check\\n        require(channel_deposit >= participant_state.deposit);\\n\\n        emit ChannelNewDeposit(\\n            channel_identifier,\\n            participant,\\n            participant_state.deposit\\n        );\\n\\n        // Do the transfer\\n        require(token.transferFrom(msg.sender, address(this), added_deposit));\\n    }\\n\\n    /// @notice Allows `participant` to withdraw tokens from the channel that he\\n    /// has with `partner`, without closing it. Can be called by anyone. Can\\n    /// only be called once per each signed withdraw message\\n    /// @param channel_identifier Identifier for the channel on which this\\n    /// operation takes place\\n    /// @param participant Channel participant, who will receive the withdrawn\\n    /// amount\\n    /// @param total_withdraw Total amount of tokens that are marked as\\n    /// withdrawn from the channel during the channel lifecycle\\n    /// @param participant_signature Participant's signature on the withdraw\\n    /// data\\n    /// @param partner_signature Partner's signature on the withdraw data\\n    function setTotalWithdraw(\\n        uint256 channel_identifier,\\n        address participant,\\n        uint256 total_withdraw,\\n        uint256 expiration_block,\\n        bytes calldata participant_signature,\\n        bytes calldata partner_signature\\n    )\\n        external\\n        isOpen(channel_identifier)\\n    {\\n        uint256 total_deposit;\\n        uint256 current_withdraw;\\n        address partner;\\n\\n        require(total_withdraw > 0);\\n        require(block.number < expiration_block);\\n\\n        // Authenticate both channel partners via their signatures.\\n        // `participant` is a part of the signed message, so given in the calldata.\\n        require(participant == TokenNetworkUtils.recoverAddressFromWithdrawMessage(\\n            chain_id,\\n            channel_identifier,\\n            participant,\\n            total_withdraw,\\n            expiration_block,\\n            participant_signature\\n        ));\\n        partner = TokenNetworkUtils.recoverAddressFromWithdrawMessage(\\n            chain_id,\\n            channel_identifier,\\n            participant,\\n            total_withdraw,\\n            expiration_block,\\n            partner_signature\\n        );\\n\\n        // Validate that authenticated partners and the channel identifier match\\n        require(channel_identifier == getChannelIdentifier(participant, partner));\\n\\n        // Read channel state after validating the function input\\n        Channel storage channel = channels[channel_identifier];\\n        Participant storage participant_state = channel.participants[participant];\\n        Participant storage partner_state = channel.participants[partner];\\n\\n        total_deposit = participant_state.deposit + partner_state.deposit;\\n\\n        // Entire withdrawn amount must not be bigger than the current channel deposit\\n        require((total_withdraw + partner_state.withdrawn_amount) <= total_deposit);\\n        require(total_withdraw <= (total_withdraw + partner_state.withdrawn_amount));\\n\\n        // Using the total_withdraw (monotonically increasing) in the signed\\n        // message ensures that we do not allow replay attack to happen, by\\n        // using the same withdraw proof twice.\\n        // Next two lines enforce the monotonicity of total_withdraw and check for an underflow:\\n        // (we use <= because current_withdraw == total_withdraw for the first withdraw)\\n        current_withdraw = total_withdraw - participant_state.withdrawn_amount;\\n        require(current_withdraw <= total_withdraw);\\n\\n        // The actual amount of tokens that will be transferred must be > 0 to disable the reuse of\\n        // withdraw messages completely.\\n        require(current_withdraw > 0);\\n\\n        // This should never fail at this point. Added check for security, because we directly set\\n        // the participant_state.withdrawn_amount = total_withdraw,\\n        // while we transfer `current_withdraw` tokens.\\n        assert(participant_state.withdrawn_amount + current_withdraw == total_withdraw);\\n\\n        emit ChannelWithdraw(\\n            channel_identifier,\\n            participant,\\n            total_withdraw\\n        );\\n\\n        // Do the state change and tokens transfer\\n        participant_state.withdrawn_amount = total_withdraw;\\n        require(token.transfer(participant, current_withdraw));\\n\\n        // This should never happen, as we have an overflow check in setTotalDeposit\\n        assert(total_deposit >= participant_state.deposit);\\n        assert(total_deposit >= partner_state.deposit);\\n\\n        // A withdraw should never happen if a participant already has a\\n        // balance proof in storage. This should never fail as we use isOpen.\\n        assert(participant_state.nonce == 0);\\n        assert(partner_state.nonce == 0);\\n\\n    }\\n\\n    /// @notice Close the channel defined by the two participant addresses.\\n    /// Anybody can call this function on behalf of a participant (called\\n    /// the closing participant), providing a balance proof signed by\\n    /// both parties. Callable only once\\n    /// @param channel_identifier Identifier for the channel on which this\\n    /// operation takes place\\n    /// @param closing_participant Channel participant who closes the channel\\n    /// @param non_closing_participant Channel partner of the `closing_participant`,\\n    /// who provided the balance proof\\n    /// @param balance_hash Hash of (transferred_amount, locked_amount,\\n    /// locksroot)\\n    /// @param additional_hash Computed from the message. Used for message\\n    /// authentication\\n    /// @param nonce Strictly monotonic value used to order transfers\\n    /// @param non_closing_signature Non-closing participant's signature of the balance proof data\\n    /// @param closing_signature Closing participant's signature of the balance\\n    /// proof data\\n    function closeChannel(\\n        uint256 channel_identifier,\\n        address non_closing_participant,\\n        address closing_participant,\\n        // The next four arguments form a balance proof.\\n        bytes32 balance_hash,\\n        uint256 nonce,\\n        bytes32 additional_hash,\\n        bytes memory non_closing_signature,\\n        bytes memory closing_signature\\n    )\\n        public\\n        isOpen(channel_identifier)\\n    {\\n        require(channel_identifier == getChannelIdentifier(closing_participant, non_closing_participant));\\n\\n        address recovered_non_closing_participant_address;\\n\\n        Channel storage channel = channels[channel_identifier];\\n\\n        channel.state = ChannelState.Closed;\\n        channel.participants[closing_participant].is_the_closer = true;\\n\\n        // This is the block number at which the channel can be settled.\\n        channel.settle_block_number += uint256(block.number);\\n\\n        // The closing participant must have signed the balance proof.\\n        address recovered_closing_participant_address = TokenNetworkUtils.recoverAddressFromBalanceProofCounterSignature(\\n            MessageType.MessageTypeId.BalanceProof,\\n            chain_id,\\n            channel_identifier,\\n            balance_hash,\\n            nonce,\\n            additional_hash,\\n            non_closing_signature,\\n            closing_signature\\n        );\\n        require(closing_participant == recovered_closing_participant_address);\\n\\n        // Nonce 0 means that the closer never received a transfer, therefore\\n        // never received a balance proof, or he is intentionally not providing\\n        // the latest transfer, in which case the closing party is going to\\n        // lose the tokens that were transferred to him.\\n        if (nonce > 0) {\\n            recovered_non_closing_participant_address = TokenNetworkUtils.recoverAddressFromBalanceProof(\\n                chain_id,\\n                channel_identifier,\\n                balance_hash,\\n                nonce,\\n                additional_hash,\\n                non_closing_signature\\n            );\\n            // Signature must be from the channel partner\\n            require(non_closing_participant == recovered_non_closing_participant_address);\\n\\n            updateBalanceProofData(\\n                channel,\\n                recovered_non_closing_participant_address,\\n                nonce,\\n                balance_hash\\n            );\\n        }\\n\\n        emit ChannelClosed(channel_identifier, closing_participant, nonce, balance_hash);\\n    }\\n\\n    /// @notice Called on a closed channel, the function allows the non-closing\\n    /// participant to provide the last balance proof, which modifies the\\n    /// closing participant's state. Can be called multiple times by anyone.\\n    /// @param channel_identifier Identifier for the channel on which this\\n    /// operation takes place\\n    /// @param closing_participant Channel participant who closed the channel\\n    /// @param non_closing_participant Channel participant who needs to update\\n    /// the balance proof\\n    /// @param balance_hash Hash of (transferred_amount, locked_amount,\\n    /// locksroot)\\n    /// @param additional_hash Computed from the message. Used for message\\n    /// authentication\\n    /// @param nonce Strictly monotonic value used to order transfers\\n    /// @param closing_signature Closing participant's signature of the balance\\n    /// proof data\\n    /// @param non_closing_signature Non-closing participant signature of the\\n    /// balance proof data\\n    function updateNonClosingBalanceProof(\\n        uint256 channel_identifier,\\n        address closing_participant,\\n        address non_closing_participant,\\n        // The next four arguments form a balance proof\\n        bytes32 balance_hash,\\n        uint256 nonce,\\n        bytes32 additional_hash,\\n        bytes calldata closing_signature,\\n        bytes calldata non_closing_signature\\n    )\\n        external\\n    {\\n        require(channel_identifier == getChannelIdentifier(\\n            closing_participant,\\n            non_closing_participant\\n        ));\\n        require(balance_hash != bytes32(0x0));\\n        require(nonce > 0);\\n\\n        address recovered_non_closing_participant;\\n        address recovered_closing_participant;\\n\\n        Channel storage channel = channels[channel_identifier];\\n\\n        require(channel.state == ChannelState.Closed);\\n\\n        // Calling this function after the settlement window is forbidden to\\n        // fix the following race condition:\\n        //\\n        // 1 A badly configured node A, that doesn't have a monitoring service\\n        //   and is temporarily offline does not call update during the\\n        //   settlement window.\\n        // 2 The well behaved partner B, who called close, sees the\\n        //   settlement window is over and calls settle. At this point the B's\\n        //   balance proofs which should be provided by A is missing, so B will\\n        //   call settle with its balance proof zeroed out.\\n        // 3 A restarts and calls update, which will change B's balance\\n        //   proof.\\n        // 4 At this point, the transactions from 2 and 3 are racing, and one\\n        //   of them will fail.\\n        //\\n        // To avoid the above race condition, which would require special\\n        // handling on both nodes, the call to update is forbidden after the\\n        // settlement window. This does not affect safety, since we assume the\\n        // nodes are always properly configured and have a monitoring service\\n        // available to call update on the user's behalf.\\n        require(channel.settle_block_number >= block.number);\\n\\n        // We need the signature from the non-closing participant to allow\\n        // anyone to make this transaction. E.g. a monitoring service.\\n        recovered_non_closing_participant = TokenNetworkUtils.recoverAddressFromBalanceProofCounterSignature(\\n            MessageType.MessageTypeId.BalanceProofUpdate,\\n            chain_id,\\n            channel_identifier,\\n            balance_hash,\\n            nonce,\\n            additional_hash,\\n            closing_signature,\\n            non_closing_signature\\n        );\\n        require(non_closing_participant == recovered_non_closing_participant);\\n\\n        recovered_closing_participant = TokenNetworkUtils.recoverAddressFromBalanceProof(\\n            chain_id,\\n            channel_identifier,\\n            balance_hash,\\n            nonce,\\n            additional_hash,\\n            closing_signature\\n        );\\n        require(closing_participant == recovered_closing_participant);\\n\\n        Participant storage closing_participant_state = channel.participants[closing_participant];\\n        // Make sure the first signature is from the closing participant\\n        require(closing_participant_state.is_the_closer);\\n\\n        // Update the balance proof data for the closing_participant\\n        updateBalanceProofData(channel, closing_participant, nonce, balance_hash);\\n\\n        emit NonClosingBalanceProofUpdated(\\n            channel_identifier,\\n            closing_participant,\\n            nonce,\\n            balance_hash\\n        );\\n    }\\n\\n    /// @notice Settles the balance between the two parties. Note that arguments\\n    /// order counts: `participant1_transferred_amount +\\n    /// participant1_locked_amount` <= `participant2_transferred_amount +\\n    /// participant2_locked_amount`\\n    /// @param channel_identifier Identifier for the channel on which this\\n    /// operation takes place\\n    /// @param participant1 Channel participant\\n    /// @param participant1_transferred_amount The latest known amount of tokens\\n    /// transferred from `participant1` to `participant2`\\n    /// @param participant1_locked_amount Amount of tokens owed by\\n    /// `participant1` to `participant2`, contained in locked transfers that\\n    /// will be retrieved by calling `unlock` after the channel is settled\\n    /// @param participant1_locksroot The latest known hash of the\\n    /// pending hash-time locks of `participant1`, used to validate the unlocked\\n    /// proofs. If no balance_hash has been submitted, locksroot is ignored\\n    /// @param participant2 Other channel participant\\n    /// @param participant2_transferred_amount The latest known amount of tokens\\n    /// transferred from `participant2` to `participant1`\\n    /// @param participant2_locked_amount Amount of tokens owed by\\n    /// `participant2` to `participant1`, contained in locked transfers that\\n    /// will be retrieved by calling `unlock` after the channel is settled\\n    /// @param participant2_locksroot The latest known hash of the\\n    /// pending hash-time locks of `participant2`, used to validate the unlocked\\n    /// proofs. If no balance_hash has been submitted, locksroot is ignored\\n    function settleChannel(\\n        uint256 channel_identifier,\\n        address participant1,\\n        uint256 participant1_transferred_amount,\\n        uint256 participant1_locked_amount,\\n        bytes32 participant1_locksroot,\\n        address participant2,\\n        uint256 participant2_transferred_amount,\\n        uint256 participant2_locked_amount,\\n        bytes32 participant2_locksroot\\n    )\\n        public\\n    {\\n        settleChannel2(\\n            channel_identifier,\\n            SettleInput({\\n                participant: participant1,\\n                transferred_amount: participant1_transferred_amount,\\n                locked_amount: participant1_locked_amount,\\n                locksroot: participant1_locksroot\\n            }),\\n            SettleInput({\\n                participant: participant2,\\n                transferred_amount: participant2_transferred_amount,\\n                locked_amount: participant2_locked_amount,\\n                locksroot: participant2_locksroot\\n            })\\n        );\\n    }\\n\\n    function settleChannel2(\\n        uint256 channel_identifier,\\n        SettleInput memory participant1_settlement,\\n        SettleInput memory participant2_settlement\\n    )\\n        public\\n    {\\n        // There are several requirements that this function MUST enforce:\\n        // - it MUST never fail; therefore, any overflows or underflows must be\\n        // handled gracefully\\n        // - it MUST ensure that if participants use the latest valid balance proofs,\\n        // provided by the official Raiden client, the participants will be able\\n        // to receive correct final balances at the end of the channel lifecycle\\n        // - it MUST ensure that the participants cannot cheat by providing an\\n        // old, valid balance proof of their partner; meaning that their partner MUST\\n        // receive at least the amount of tokens that he would have received if\\n        // the latest valid balance proofs are used.\\n        // - the contract cannot determine if a balance proof is invalid (values\\n        // are not within the constraints enforced by the official Raiden client),\\n        // therefore it cannot ensure correctness. Users MUST use the official\\n        // Raiden clients for signing balance proofs.\\n\\n        address participant1 = participant1_settlement.participant;\\n        address participant2 = participant2_settlement.participant;\\n        require(channel_identifier == getChannelIdentifier(participant1, participant2));\\n\\n        bytes32 pair_hash;\\n\\n        pair_hash = getParticipantsHash(participant1, participant2);\\n        Channel storage channel = channels[channel_identifier];\\n\\n        require(channel.state == ChannelState.Closed);\\n\\n        // Settlement window must be over\\n        require(channel.settle_block_number < block.number);\\n\\n        Participant storage participant1_state = channel.participants[participant1];\\n        Participant storage participant2_state = channel.participants[participant2];\\n\\n        require(verifyBalanceHashData(\\n            participant1_state,\\n            participant1_settlement\\n        ));\\n\\n        require(verifyBalanceHashData(\\n            participant2_state,\\n            participant2_settlement\\n        ));\\n\\n        // We are calculating the final token amounts that need to be\\n        // transferred to the participants now and the amount of tokens that\\n        // need to remain locked in the contract. These tokens can be unlocked\\n        // by calling `unlock`.\\n        // participant1_transferred_amount = the amount of tokens that\\n        //   participant1 will receive in this transaction.\\n        // participant2_transferred_amount = the amount of tokens that\\n        //   participant2 will receive in this transaction.\\n        // participant1_locked_amount = the amount of tokens remaining in the\\n        //   contract, representing pending transfers from participant1 to participant2.\\n        // participant2_locked_amount = the amount of tokens remaining in the\\n        //   contract, representing pending transfers from participant2 to participant1.\\n        // We are reusing variables due to the local variables number limit.\\n        // For better readability this can be refactored further.\\n        (\\n            participant1_settlement.transferred_amount,\\n            participant2_settlement.transferred_amount,\\n            participant1_settlement.locked_amount,\\n            participant2_settlement.locked_amount\\n        ) = getSettleTransferAmounts(\\n            participant1_state,\\n            participant1_settlement.transferred_amount,\\n            participant1_settlement.locked_amount,\\n            participant2_state,\\n            participant2_settlement.transferred_amount,\\n            participant2_settlement.locked_amount\\n        );\\n\\n        // Remove the channel data from storage\\n        delete channel.participants[participant1];\\n        delete channel.participants[participant2];\\n        delete channels[channel_identifier];\\n\\n        // Remove the pair's channel counter\\n        delete participants_hash_to_channel_identifier[pair_hash];\\n\\n        // Store balance data needed for `unlock`, including the calculated\\n        // locked amounts remaining in the contract.\\n        storeUnlockData(\\n            channel_identifier,\\n            participant1_settlement,\\n            participant2\\n        );\\n        storeUnlockData(\\n            channel_identifier,\\n            participant2_settlement,\\n            participant1\\n        );\\n\\n        emit ChannelSettled(\\n            channel_identifier,\\n            participant1_settlement.transferred_amount,\\n            participant1_settlement.locksroot,\\n            participant2_settlement.transferred_amount,\\n            participant2_settlement.locksroot\\n        );\\n\\n        // Do the actual token transfers\\n        if (participant1_settlement.transferred_amount > 0) {\\n            require(token.transfer(participant1, participant1_settlement.transferred_amount));\\n        }\\n\\n        if (participant2_settlement.transferred_amount > 0) {\\n            require(token.transfer(participant2, participant2_settlement.transferred_amount));\\n        }\\n    }\\n\\n    /// @notice Unlocks all pending off-chain transfers from `sender` to\\n    /// `receiver` and sends the locked tokens corresponding to locks with\\n    /// secrets registered on-chain to the `receiver`. Locked tokens\\n    /// corresponding to locks where the secret was not revealed on-chain will\\n    /// return to the `sender`. Anyone can call unlock.\\n    /// @param channel_identifier Identifier for the channel on which this\\n    /// operation takes place\\n    /// @param receiver Address who will receive the claimable unlocked\\n    /// tokens\\n    /// @param sender Address who sent the pending transfers and will receive\\n    /// the unclaimable unlocked tokens\\n    /// @param locks All pending locks concatenated in order of creation\\n    /// that `sender` sent to `receiver`\\n    function unlock(\\n        uint256 channel_identifier,\\n        address receiver,\\n        address sender,\\n        bytes memory locks\\n    )\\n        public\\n    {\\n        // Channel represented by channel_identifier must be settled and\\n        // channel data deleted\\n        require(channel_identifier != getChannelIdentifier(receiver, sender));\\n\\n        // After the channel is settled the storage is cleared, therefore the\\n        // value will be NonExistent and not Settled. The value Settled is used\\n        // for the external APIs\\n        require(channels[channel_identifier].state == ChannelState.NonExistent);\\n\\n        bytes32 unlock_key;\\n        bytes32 computed_locksroot;\\n        uint256 unlocked_amount;\\n        uint256 locked_amount;\\n        uint256 returned_tokens;\\n\\n        // Calculate the locksroot for the pending transfers and the amount of\\n        // tokens corresponding to the locked transfers with secrets revealed\\n        // on chain.\\n        (computed_locksroot, unlocked_amount) = getHashAndUnlockedAmount(\\n            locks\\n        );\\n\\n        // The sender must have a non-empty locksroot on-chain that must be\\n        // the same as the computed locksroot.\\n        // Get the amount of tokens that have been left in the contract, to\\n        // account for the pending transfers `sender` -> `receiver`.\\n        unlock_key = getUnlockIdentifier(channel_identifier, sender, receiver);\\n        UnlockData storage unlock_data = unlock_identifier_to_unlock_data[unlock_key];\\n        locked_amount = unlock_data.locked_amount;\\n\\n        // Locksroot must be the same as the computed locksroot\\n        require(unlock_data.locksroot == computed_locksroot);\\n\\n        // There are no pending transfers if the locked_amount is 0.\\n        // Transaction must fail\\n        require(locked_amount > 0);\\n\\n        // Make sure we don't transfer more tokens than previously reserved in\\n        // the smart contract.\\n        unlocked_amount = TokenNetworkUtils.min(unlocked_amount, locked_amount);\\n\\n        // Transfer the rest of the tokens back to the sender\\n        returned_tokens = locked_amount - unlocked_amount;\\n\\n        // Remove sender's unlock data\\n        delete unlock_identifier_to_unlock_data[unlock_key];\\n\\n        emit ChannelUnlocked(\\n            channel_identifier,\\n            receiver,\\n            sender,\\n            computed_locksroot,\\n            unlocked_amount,\\n            returned_tokens\\n        );\\n\\n        // Transfer the unlocked tokens to the receiver. unlocked_amount can\\n        // be 0\\n        if (unlocked_amount > 0) {\\n            require(token.transfer(receiver, unlocked_amount));\\n        }\\n\\n        // Transfer the rest of the tokens back to the sender\\n        if (returned_tokens > 0) {\\n            require(token.transfer(sender, returned_tokens));\\n        }\\n\\n        // At this point, this should always be true\\n        assert(locked_amount >= returned_tokens);\\n        assert(locked_amount >= unlocked_amount);\\n    }\\n\\n    /* /// @notice Cooperatively settles the balances between the two channel\\n    /// participants and transfers the agreed upon token amounts to the\\n    /// participants. After this the channel lifecycle has ended and no more\\n    /// operations can be done on it.\\n    /// @param channel_identifier Identifier for the channel on which this\\n    /// operation takes place\\n    /// @param participant1_address Address of channel participant\\n    /// @param participant1_balance Amount of tokens that `participant1_address`\\n    /// must receive when the channel is settled and removed\\n    /// @param participant2_address Address of the other channel participant\\n    /// @param participant2_balance Amount of tokens that `participant2_address`\\n    /// must receive when the channel is settled and removed\\n    /// @param participant1_signature Signature of `participant1_address` on the\\n    /// cooperative settle message\\n    /// @param participant2_signature Signature of `participant2_address` on the\\n    /// cooperative settle message\\n    function cooperativeSettle(\\n        uint256 channel_identifier,\\n        address participant1_address,\\n        uint256 participant1_balance,\\n        address participant2_address,\\n        uint256 participant2_balance,\\n        bytes participant1_signature,\\n        bytes participant2_signature\\n    )\\n        public\\n    {\\n        require(channel_identifier == getChannelIdentifier(\\n            participant1_address,\\n            participant2_address\\n        ));\\n        bytes32 pair_hash;\\n        address participant1;\\n        address participant2;\\n        uint256 total_available_deposit;\\n\\n        pair_hash = getParticipantsHash(participant1_address, participant2_address);\\n        Channel storage channel = channels[channel_identifier];\\n\\n        require(channel.state == ChannelState.Opened);\\n\\n        participant1 = TokenNetworkUtils.recoverAddressFromCooperativeSettleSignature(\\n            channel_identifier,\\n            participant1_address,\\n            participant1_balance,\\n            participant2_address,\\n            participant2_balance,\\n            participant1_signature\\n        );\\n        // The provided address must be the same as the recovered one\\n        require(participant1 == participant1_address);\\n\\n        participant2 = TokenNetworkUtils.recoverAddressFromCooperativeSettleSignature(\\n            channel_identifier,\\n            participant1_address,\\n            participant1_balance,\\n            participant2_address,\\n            participant2_balance,\\n            participant2_signature\\n        );\\n        // The provided address must be the same as the recovered one\\n        require(participant2 == participant2_address);\\n\\n        Participant storage participant1_state = channel.participants[participant1];\\n        Participant storage participant2_state = channel.participants[participant2];\\n\\n        total_available_deposit = getChannelAvailableDeposit(\\n            participant1_state,\\n            participant2_state\\n        );\\n        // The sum of the provided balances must be equal to the total\\n        // available deposit\\n        require(total_available_deposit == (participant1_balance + participant2_balance));\\n        // Overflow check for the balances addition from the above check.\\n        // This overflow should never happen if the token.transfer function is implemented\\n        // correctly. We do not control the token implementation, therefore we add this\\n        // check for safety.\\n        require(participant1_balance <= participant1_balance + participant2_balance);\\n\\n        // Remove channel data from storage before doing the token transfers\\n        delete channel.participants[participant1];\\n        delete channel.participants[participant2];\\n        delete channels[channel_identifier];\\n\\n        // Remove the pair's channel counter\\n        delete participants_hash_to_channel_identifier[pair_hash];\\n\\n        emit ChannelSettled(channel_identifier, participant1_balance, participant2_balance);\\n\\n        // Do the token transfers\\n        if (participant1_balance > 0) {\\n            require(token.transfer(participant1, participant1_balance));\\n        }\\n\\n        if (participant2_balance > 0) {\\n            require(token.transfer(participant2, participant2_balance));\\n        }\\n    } */\\n\\n    /// @notice Returns the unique identifier for the channel given by the\\n    /// contract\\n    /// @param participant Address of a channel participant\\n    /// @param partner Address of the other channel participant\\n    /// @return Unique identifier for the channel. It can be 0 if channel does\\n    /// not exist\\n    function getChannelIdentifier(address participant, address partner)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        require(participant != address(0x0));\\n        require(partner != address(0x0));\\n        require(participant != partner);\\n\\n        bytes32 pair_hash = getParticipantsHash(participant, partner);\\n        return participants_hash_to_channel_identifier[pair_hash];\\n    }\\n\\n    /// @dev Returns the channel specific data.\\n    /// @param channel_identifier Identifier for the channel on which this\\n    /// operation takes place\\n    /// @param participant1 Address of a channel participant\\n    /// @param participant2 Address of the other channel participant\\n    /// @return Channel settle_block_number and state\\n    /// @notice The contract cannot really distinguish Settled and Removed\\n    /// states, especially when wrong participants are given as input.\\n    /// The contract does not remember the participants of the channel\\n    function getChannelInfo(\\n        uint256 channel_identifier,\\n        address participant1,\\n        address participant2\\n    )\\n        external\\n        view\\n        returns (uint256, ChannelState)\\n    {\\n        bytes32 unlock_key1;\\n        bytes32 unlock_key2;\\n\\n        Channel storage channel = channels[channel_identifier];\\n        ChannelState state = channel.state;  // This must **not** update the storage\\n\\n        if (state == ChannelState.NonExistent &&\\n            channel_identifier > 0 &&\\n            channel_identifier <= channel_counter\\n        ) {\\n            // The channel has been settled, channel data is removed Therefore,\\n            // the channel state in storage is actually `0`, or `NonExistent`\\n            // However, for this view function, we return `Settled`, in order\\n            // to provide a consistent external API\\n            state = ChannelState.Settled;\\n\\n            // We might still have data stored for future unlock operations\\n            // Only if we do not, we can consider the channel as `Removed`\\n            unlock_key1 = getUnlockIdentifier(channel_identifier, participant1, participant2);\\n            UnlockData storage unlock_data1 = unlock_identifier_to_unlock_data[unlock_key1];\\n\\n            unlock_key2 = getUnlockIdentifier(channel_identifier, participant2, participant1);\\n            UnlockData storage unlock_data2 = unlock_identifier_to_unlock_data[unlock_key2];\\n\\n            if (unlock_data1.locked_amount == 0 && unlock_data2.locked_amount == 0) {\\n                state = ChannelState.Removed;\\n            }\\n        }\\n\\n        return (\\n            channel.settle_block_number,\\n            state\\n        );\\n    }\\n\\n    /// @dev Returns the channel specific data.\\n    /// @param channel_identifier Identifier for the channel on which this\\n    /// operation takes place\\n    /// @param participant Address of the channel participant whose data will be\\n    /// returned\\n    /// @param partner Address of the channel partner\\n    /// @return Participant's deposit, withdrawn_amount, whether the participant\\n    /// has called `closeChannel` or not, balance_hash, nonce, locksroot,\\n    /// locked_amount\\n    function getChannelParticipantInfo(\\n            uint256 channel_identifier,\\n            address participant,\\n            address partner\\n    )\\n        external\\n        view\\n        returns (uint256, uint256, bool, bytes32, uint256, bytes32, uint256)\\n    {\\n        bytes32 unlock_key;\\n\\n        Participant storage participant_state = channels[channel_identifier].participants[\\n            participant\\n        ];\\n        unlock_key = getUnlockIdentifier(channel_identifier, participant, partner);\\n        UnlockData storage unlock_data = unlock_identifier_to_unlock_data[unlock_key];\\n\\n        return (\\n            participant_state.deposit,\\n            participant_state.withdrawn_amount,\\n            participant_state.is_the_closer,\\n            participant_state.balance_hash,\\n            participant_state.nonce,\\n            unlock_data.locksroot,\\n            unlock_data.locked_amount\\n        );\\n    }\\n\\n    /// @dev Get the hash of the participant addresses, ordered\\n    /// lexicographically\\n    /// @param participant Address of a channel participant\\n    /// @param partner Address of the other channel participant\\n    function getParticipantsHash(address participant, address partner)\\n        public\\n        pure\\n        returns (bytes32)\\n    {\\n        require(participant != address(0x0));\\n        require(partner != address(0x0));\\n        require(participant != partner);\\n\\n        if (participant < partner) {\\n            return keccak256(abi.encodePacked(participant, partner));\\n        } else {\\n            return keccak256(abi.encodePacked(partner, participant));\\n        }\\n    }\\n\\n    /// @dev Get the hash of the channel identifier and the participant\\n    /// addresses (whose ordering matters). The hash might be useful for\\n    /// the receiver to look up the appropriate UnlockData to claim\\n    /// @param channel_identifier Identifier for the channel which the\\n    /// UnlockData is about\\n    /// @param sender Sender of the pending transfers that the UnlockData\\n    /// represents\\n    /// @param receiver Receiver of the pending transfers that the UnlockData\\n    /// represents\\n    function getUnlockIdentifier(\\n        uint256 channel_identifier,\\n        address sender,\\n        address receiver\\n    )\\n        public\\n        pure\\n        returns (bytes32)\\n    {\\n        require(sender != receiver);\\n        return keccak256(abi.encodePacked(channel_identifier, sender, receiver));\\n    }\\n\\n    function updateBalanceProofData(\\n        Channel storage channel,\\n        address participant,\\n        uint256 nonce,\\n        bytes32 balance_hash\\n    )\\n        internal\\n    {\\n        Participant storage participant_state = channel.participants[participant];\\n\\n        // Multiple calls to updateNonClosingBalanceProof can be made and we\\n        // need to store the last known balance proof data.\\n        // This line prevents Monitoring Services from getting rewards\\n        // again and again using the same reward proof.\\n        require(nonce > participant_state.nonce);\\n\\n        participant_state.nonce = nonce;\\n        participant_state.balance_hash = balance_hash;\\n    }\\n\\n    function storeUnlockData(\\n        uint256 channel_identifier,\\n        SettleInput memory settle_input,\\n        address receiver\\n    )\\n        internal\\n    {\\n        // If there are transfers to unlock, store the locksroot and total\\n        // amount of tokens\\n        if (settle_input.locked_amount == 0) {\\n            return;\\n        }\\n\\n        bytes32 key = getUnlockIdentifier(channel_identifier, settle_input.participant, receiver);\\n        UnlockData storage unlock_data = unlock_identifier_to_unlock_data[key];\\n        unlock_data.locksroot = settle_input.locksroot;\\n        unlock_data.locked_amount = settle_input.locked_amount;\\n    }\\n\\n    function getChannelAvailableDeposit(\\n        Participant storage participant1_state,\\n        Participant storage participant2_state\\n    )\\n        internal\\n        view\\n        returns (uint256 total_available_deposit)\\n    {\\n        total_available_deposit = (\\n            participant1_state.deposit +\\n            participant2_state.deposit -\\n            participant1_state.withdrawn_amount -\\n            participant2_state.withdrawn_amount\\n        );\\n    }\\n\\n    /// @dev Function that calculates the amount of tokens that the participants\\n    /// will receive when calling settleChannel.\\n    /// Check https://github.com/raiden-network/raiden-contracts/issues/188 for the settlement\\n    /// algorithm analysis and explanations.\\n    function getSettleTransferAmounts(\\n        Participant storage participant1_state,\\n        uint256 participant1_transferred_amount,\\n        uint256 participant1_locked_amount,\\n        Participant storage participant2_state,\\n        uint256 participant2_transferred_amount,\\n        uint256 participant2_locked_amount\\n    )\\n        private\\n        view\\n        returns (uint256, uint256, uint256, uint256)\\n    {\\n        // The scope of this function is to compute the settlement amounts that\\n        // the two channel participants will receive when calling settleChannel\\n        // and the locked amounts that remain in the contract, to account for\\n        // the pending, not finalized transfers, that will be received by the\\n        // participants when calling `unlock`.\\n\\n        // The amount of tokens that participant1 MUST receive at the end of\\n        // the channel lifecycle (after settleChannel and unlock) is:\\n        // B1 = D1 - W1 + T2 - T1 + Lc2 - Lc1\\n\\n        // The amount of tokens that participant2 MUST receive at the end of\\n        // the channel lifecycle (after settleChannel and unlock) is:\\n        // B2 = D2 - W2 + T1 - T2 + Lc1 - Lc2\\n\\n        // B1 + B2 = TAD = D1 + D2 - W1 - W2\\n        // TAD = total available deposit at settlement time\\n\\n        // L1 = Lc1 + Lu1\\n        // L2 = Lc2 + Lu2\\n\\n        // where:\\n        // B1 = final balance of participant1 after the channel is removed\\n        // D1 = total amount deposited by participant1 into the channel\\n        // W1 = total amount withdrawn by participant1 from the channel\\n        // T2 = total amount transferred by participant2 to participant1 (finalized transfers)\\n        // T1 = total amount transferred by participant1 to participant2 (finalized transfers)\\n        // L1 = total amount of tokens locked in pending transfers, sent by\\n        //   participant1 to participant2\\n        // L2 = total amount of tokens locked in pending transfers, sent by\\n        //   participant2 to participant1\\n        // Lc2 = the amount that can be claimed by participant1 from the pending\\n        //   transfers (that have not been finalized off-chain), sent by\\n        //   participant2 to participant1. These are part of the locked amount\\n        //   value from participant2's balance proof. They are considered claimed\\n        //   if the secret corresponding to these locked transfers was registered\\n        //   on-chain, in the SecretRegistry contract, before the lock's expiration.\\n        // Lu1 = unclaimable locked amount from L1\\n        // Lc1 = the amount that can be claimed by participant2 from the pending\\n        //   transfers (that have not been finalized off-chain),\\n        //   sent by participant1 to participant2\\n        // Lu2 = unclaimable locked amount from L2\\n\\n        // Notes:\\n        // 1) The unclaimble tokens from a locked amount will return to the sender.\\n        // At the time of calling settleChannel, the TokenNetwork contract does\\n        // not know what locked amounts are claimable or unclaimable.\\n        // 2) There are some Solidity constraints that make the calculations\\n        // more difficult: attention to overflows and underflows, that MUST be\\n        // handled without throwing.\\n\\n        // Cases that require attention:\\n        // case1. If participant1 does NOT provide a balance proof or provides\\n        // an old balance proof.  participant2_transferred_amount can be [0,\\n        // real_participant2_transferred_amount) We MUST NOT punish\\n        // participant2.\\n        // case2. If participant2 does NOT provide a balance proof or provides\\n        // an old balance proof.  participant1_transferred_amount can be [0,\\n        // real_participant1_transferred_amount) We MUST NOT punish\\n        // participant1.\\n        // case3. If neither participants provide a balance proof, we just\\n        // subtract their withdrawn amounts from their deposits.\\n\\n        // This is why, the algorithm implemented in Solidity is:\\n        // (explained at each step, below)\\n        // RmaxP1 = (T2 + L2) - (T1 + L1) + D1 - W1\\n        // RmaxP1 = min(TAD, RmaxP1)\\n        // RmaxP2 = TAD - RmaxP1\\n        // SL2 = min(RmaxP1, L2)\\n        // S1 = RmaxP1 - SL2\\n        // SL1 = min(RmaxP2, L1)\\n        // S2 = RmaxP2 - SL1\\n\\n        // where:\\n        // RmaxP1 = due to possible over/underflows that only appear when using\\n        //    old balance proofs & the fact that settlement balance calculation\\n        //    is symmetric (we can calculate either RmaxP1 and RmaxP2 first,\\n        //    order does not affect result), this is a convention used to determine\\n        //    the maximum receivable amount of participant1 at settlement time\\n        // S1 = amount received by participant1 when calling settleChannel\\n        // SL1 = the maximum amount from L1 that can be locked in the\\n        //   TokenNetwork contract when calling settleChannel (due to overflows\\n        //   that only happen when using old balance proofs)\\n        // S2 = amount received by participant2 when calling settleChannel\\n        // SL2 = the maximum amount from L2 that can be locked in the\\n        //   TokenNetwork contract when calling settleChannel (due to overflows\\n        //   that only happen when using old balance proofs)\\n\\n        uint256 participant1_amount;\\n        uint256 participant2_amount;\\n        uint256 total_available_deposit;\\n\\n        SettlementData memory participant1_settlement;\\n        SettlementData memory participant2_settlement;\\n\\n        participant1_settlement.deposit = participant1_state.deposit;\\n        participant1_settlement.withdrawn = participant1_state.withdrawn_amount;\\n        participant1_settlement.transferred = participant1_transferred_amount;\\n        participant1_settlement.locked = participant1_locked_amount;\\n\\n        participant2_settlement.deposit = participant2_state.deposit;\\n        participant2_settlement.withdrawn = participant2_state.withdrawn_amount;\\n        participant2_settlement.transferred = participant2_transferred_amount;\\n        participant2_settlement.locked = participant2_locked_amount;\\n\\n        // TAD = D1 + D2 - W1 - W2 = total available deposit at settlement time\\n        total_available_deposit = getChannelAvailableDeposit(\\n            participant1_state,\\n            participant2_state\\n        );\\n\\n        // RmaxP1 = (T2 + L2) - (T1 + L1) + D1 - W1\\n        // This amount is the maximum possible amount that participant1 can\\n        // receive at settlement time and also contains the entire locked amount\\n        //  of the pending transfers from participant2 to participant1.\\n        participant1_amount = getMaxPossibleReceivableAmount(\\n            participant1_settlement,\\n            participant2_settlement\\n        );\\n\\n        // RmaxP1 = min(TAD, RmaxP1)\\n        // We need to bound this to the available channel deposit in order to\\n        // not send tokens from other channels. The only case where TAD is\\n        // smaller than RmaxP1 is when at least one balance proof is old.\\n        participant1_amount = TokenNetworkUtils.min(participant1_amount, total_available_deposit);\\n\\n        // RmaxP2 = TAD - RmaxP1\\n        // Now it is safe to subtract without underflow\\n        participant2_amount = total_available_deposit - participant1_amount;\\n\\n        // SL2 = min(RmaxP1, L2)\\n        // S1 = RmaxP1 - SL2\\n        // Both operations are done by failsafe_subtract\\n        // We take out participant2's pending transfers locked amount, bounding\\n        // it by the maximum receivable amount of participant1\\n        (participant1_amount, participant2_locked_amount) = TokenNetworkUtils.failsafe_subtract(\\n            participant1_amount,\\n            participant2_locked_amount\\n        );\\n\\n        // SL1 = min(RmaxP2, L1)\\n        // S2 = RmaxP2 - SL1\\n        // Both operations are done by failsafe_subtract\\n        // We take out participant1's pending transfers locked amount, bounding\\n        // it by the maximum receivable amount of participant2\\n        (participant2_amount, participant1_locked_amount) = TokenNetworkUtils.failsafe_subtract(\\n            participant2_amount,\\n            participant1_locked_amount\\n        );\\n\\n        // This should never throw:\\n        // S1 and S2 MUST be smaller than TAD\\n        assert(participant1_amount <= total_available_deposit);\\n        assert(participant2_amount <= total_available_deposit);\\n        // S1 + S2 + SL1 + SL2 == TAD\\n        assert(total_available_deposit == (\\n            participant1_amount +\\n            participant2_amount +\\n            participant1_locked_amount +\\n            participant2_locked_amount\\n        ));\\n\\n        return (\\n            participant1_amount,\\n            participant2_amount,\\n            participant1_locked_amount,\\n            participant2_locked_amount\\n        );\\n    }\\n\\n    function getMaxPossibleReceivableAmount(\\n        SettlementData memory participant1_settlement,\\n        SettlementData memory participant2_settlement\\n    )\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        return TokenNetworkUtils.getMaxPossibleReceivableAmount(\\n            participant1_settlement.deposit,\\n            participant1_settlement.withdrawn,\\n            participant1_settlement.transferred,\\n            participant1_settlement.locked,\\n            participant2_settlement.deposit,\\n            participant2_settlement.withdrawn,\\n            participant2_settlement.transferred,\\n            participant2_settlement.locked\\n        );\\n    }\\n\\n    function verifyBalanceHashData(\\n        Participant storage participant,\\n        SettleInput memory settle_input\\n    )\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        // When no balance proof has been provided, we need to check this\\n        // separately because hashing values of 0 outputs a value != 0\\n        if (participant.balance_hash == 0 &&\\n            settle_input.transferred_amount == 0 &&\\n            settle_input.locked_amount == 0\\n            /* locksroot is ignored. */\\n        ) {\\n            return true;\\n        }\\n\\n        // Make sure the hash of the provided state is the same as the stored\\n        // balance_hash\\n        return participant.balance_hash == keccak256(abi.encodePacked(\\n            settle_input.transferred_amount,\\n            settle_input.locked_amount,\\n            settle_input.locksroot\\n        ));\\n    }\\n\\n    /// @dev Calculates the hash of the pending transfers data and\\n    /// calculates the amount of tokens that can be unlocked because the secret\\n    /// was registered on-chain.\\n    function getHashAndUnlockedAmount(bytes memory locks)\\n        internal\\n        view\\n        returns (bytes32, uint256)\\n    {\\n        uint256 length = locks.length;\\n\\n        // each lock has this form:\\n        // (locked_amount || expiration_block || secrethash) = 3 * 32 bytes\\n        require(length % 96 == 0);\\n\\n        uint256 i;\\n        uint256 total_unlocked_amount;\\n        uint256 unlocked_amount;\\n        bytes32 total_hash;\\n\\n        for (i = 32; i < length; i += 96) {\\n            unlocked_amount = getLockedAmountFromLock(locks, i);\\n            total_unlocked_amount += unlocked_amount;\\n        }\\n\\n        total_hash = keccak256(locks);\\n\\n        return (total_hash, total_unlocked_amount);\\n    }\\n\\n    function getLockedAmountFromLock(bytes memory locks, uint256 offset)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        uint256 expiration_block;\\n        uint256 locked_amount;\\n        uint256 reveal_block;\\n        bytes32 secrethash;\\n\\n        if (locks.length <= offset) {\\n            return 0;\\n        }\\n\\n        assembly { // solium-disable-line security/no-inline-assembly\\n            expiration_block := mload(add(locks, offset))\\n            locked_amount := mload(add(locks, add(offset, 32)))\\n            secrethash := mload(add(locks, add(offset, 64)))\\n        }\\n\\n        // Check if the lock's secret was revealed in the SecretRegistry The\\n        // secret must have been revealed in the SecretRegistry contract before\\n        // the lock's expiration_block in order for the hash time lock transfer\\n        // to be successful.\\n        reveal_block = secret_registry.getSecretRevealBlockHeight(secrethash);\\n        if (reveal_block == 0 || expiration_block <= reveal_block) {\\n            locked_amount = 0;\\n        }\\n\\n        return locked_amount;\\n    }\\n}\\n\",\"keccak256\":\"0xef9c79f097264092c65b322d121b8ffc6aeb2d7302d47c438fe1fc4bc53f1ad5\",\"license\":\"MIT\"},\"data/source/raiden/TokenNetworkRegistry.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n/* solium-disable error-reason */\\npragma solidity 0.7.6;\\n\\nimport \\\"./Utils.sol\\\";\\nimport \\\"./Token.sol\\\";\\nimport \\\"./TokenNetwork.sol\\\";\\n\\n\\n/// @title TokenNetworkRegistry\\n/// @notice The TokenNetwork Registry deploys new TokenNetwork contracts for the\\n/// Raiden Network protocol.\\ncontract TokenNetworkRegistry is Utils {\\n    address public secret_registry_address;\\n    uint256 public chain_id;\\n    uint256 public settlement_timeout_min;\\n    uint256 public settlement_timeout_max;\\n    uint256 public max_token_networks;\\n\\n    // Only for the limited Red Eyes release\\n    address public deprecation_executor;\\n    uint256 public token_network_created = 0;\\n\\n    // Token address => TokenNetwork address\\n    mapping(address => address) public token_to_token_networks;\\n\\n    event TokenNetworkCreated(address indexed token_address, address indexed token_network_address);\\n\\n    modifier canCreateTokenNetwork() {\\n        require(token_network_created < max_token_networks, \\\"registry full\\\");\\n        _;\\n    }\\n\\n    /// @param _secret_registry_address The address of SecretRegistry that's used by all\\n    /// TokenNetworks created by this contract\\n    /// @param _chain_id EIP-155 Chain-ID of the chain where this contract is deployed\\n    /// @param _settlement_timeout_min The shortest settlement period (in number of blocks)\\n    /// that can be chosen at the channel opening\\n    /// @param _settlement_timeout_max The longest settlement period (in number of blocks)\\n    /// that can be chosen at the channel opening\\n    /// @param _max_token_networks the number of tokens that can be registered\\n    /// MAX_UINT256 means no limits\\n    constructor(\\n        address _secret_registry_address,\\n        uint256 _chain_id,\\n        uint256 _settlement_timeout_min,\\n        uint256 _settlement_timeout_max,\\n        uint256 _max_token_networks\\n    ) {\\n        require(_chain_id > 0);\\n        require(_settlement_timeout_min > 0);\\n        require(_settlement_timeout_max > 0);\\n        require(_settlement_timeout_max > _settlement_timeout_min);\\n        require(_secret_registry_address != address(0x0));\\n        require(contractExists(_secret_registry_address));\\n        require(_max_token_networks > 0);\\n        secret_registry_address = _secret_registry_address;\\n        chain_id = _chain_id;\\n        settlement_timeout_min = _settlement_timeout_min;\\n        settlement_timeout_max = _settlement_timeout_max;\\n        max_token_networks = _max_token_networks;\\n\\n        deprecation_executor = msg.sender;\\n    }\\n\\n    /// @notice Deploy a new TokenNetwork contract for the Token deployed at\\n    /// `_token_address`\\n    /// @param _token_address Ethereum address of an already deployed token, to\\n    /// be used in the new TokenNetwork contract\\n    function createERC20TokenNetwork(\\n        address _token_address,\\n        uint256 _channel_participant_deposit_limit,\\n        uint256 _token_network_deposit_limit\\n    )\\n        external\\n        canCreateTokenNetwork\\n        returns (address token_network_address)\\n    {\\n        require(token_to_token_networks[_token_address] == address(0x0));\\n\\n        // We limit the number of token networks to 1 for the Bug Bounty release\\n        token_network_created = token_network_created + 1;\\n\\n        TokenNetwork token_network;\\n\\n        // Token contract checks are in the corresponding TokenNetwork contract\\n        token_network = new TokenNetwork(\\n            _token_address,\\n            secret_registry_address,\\n            chain_id,\\n            settlement_timeout_min,\\n            settlement_timeout_max,\\n            deprecation_executor,\\n            _channel_participant_deposit_limit,\\n            _token_network_deposit_limit\\n        );\\n\\n        token_network_address = address(token_network);\\n\\n        token_to_token_networks[_token_address] = token_network_address;\\n        emit TokenNetworkCreated(_token_address, token_network_address);\\n\\n        return token_network_address;\\n    }\\n}\\n\\n// MIT License\\n\\n// Copyright (c) 2018\\n\\n// Permission is hereby granted, free of charge, to any person obtaining a copy\\n// of this software and associated documentation files (the \\\"Software\\\"), to deal\\n// in the Software without restriction, including without limitation the rights\\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n// copies of the Software, and to permit persons to whom the Software is\\n// furnished to do so, subject to the following conditions:\\n\\n// The above copyright notice and this permission notice shall be included in all\\n// copies or substantial portions of the Software.\\n\\n// THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n// SOFTWARE.\\n\",\"keccak256\":\"0x6ac2b18eec420639447a0d7879094357e15e398d9f222c48fe6701a7cde01a5c\",\"license\":\"MIT\"},\"data/source/raiden/Utils.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.6;\\n\\n/// @title Utils\\n/// @notice Utils contract for various helpers used by the Raiden Network smart\\n/// contracts.\\ncontract Utils {\\n    /// @notice Check if a contract exists\\n    /// @param contract_address The address to check whether a contract is\\n    /// deployed or not\\n    /// @return True if a contract exists, false otherwise\\n    function contractExists(address contract_address) public view returns (bool) {\\n        uint size;\\n\\n        assembly { // solium-disable-line security/no-inline-assembly\\n            size := extcodesize(contract_address)\\n        }\\n\\n        return size > 0;\\n    }\\n}\\n\",\"keccak256\":\"0x3fb4df9cdadd3711bffff81a451868c7a1ee8a2f3ff1a20a4343def15cb38e0f\",\"license\":\"MIT\"},\"data/source/services/MonitoringService.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.6;\\n\\nimport \\\"../lib/ECVerify.sol\\\";\\nimport \\\"../lib/MessageType.sol\\\";\\nimport \\\"../raiden/Token.sol\\\";\\nimport \\\"../raiden/Utils.sol\\\";\\nimport \\\"../raiden/TokenNetwork.sol\\\";\\nimport \\\"../raiden/TokenNetworkRegistry.sol\\\";\\nimport \\\"./ServiceRegistry.sol\\\";\\nimport \\\"./UserDeposit.sol\\\";\\n\\ncontract MonitoringService is Utils {\\n    // Token to be used for paying the rewards\\n    Token public token;\\n\\n    // Raiden Service Bundle contract to use for checking if MS has deposits\\n    ServiceRegistry public service_registry;\\n    UserDeposit public user_deposit;\\n    TokenNetworkRegistry public token_network_registry;\\n\\n    // keccak256(channel_identifier, token_network_address) => Struct\\n    // Keep track of the rewards per channel\\n    mapping(bytes32 => Reward) internal rewards;\\n\\n    /*\\n     *  Structs\\n     */\\n    struct Reward{\\n        // The amount of tokens to be rewarded\\n        uint256 reward_amount;\\n\\n        // Nonce of the most recently provided BP\\n        uint256 nonce;\\n\\n        // Address of the Raiden Node that was monitored\\n        // This is also the address that has the reward deducted from its deposit\\n        address reward_sender_address;\\n\\n        // Address of the Monitoring Service who is currently eligible to claim the reward\\n        address monitoring_service_address;\\n    }\\n\\n    /*\\n     *  Events\\n     */\\n\\n    event NewBalanceProofReceived(\\n        address token_network_address,\\n        uint256 channel_identifier,\\n        uint256 reward_amount,\\n        uint256 indexed nonce,\\n        address indexed ms_address,\\n        address indexed raiden_node_address\\n    );\\n    event RewardClaimed(address indexed ms_address, uint amount, bytes32 indexed reward_identifier);\\n\\n    /*\\n     *  Constructor\\n     */\\n\\n    /// @notice Set the default values for the smart contract\\n    /// @param _token_address The address of the token to use for rewards\\n    /// @param _service_registry_address The address of the ServiceRegistry contract\\n    /// @param _token_network_registry_address The address of the TokenNetworkRegistry for authenticating TokenNetworks\\n    constructor(\\n        address _token_address,\\n        address _service_registry_address,\\n        address _udc_address,\\n        address _token_network_registry_address\\n    ) {\\n        require(_token_address != address(0x0), \\\"Token at address zero\\\");\\n        require(_service_registry_address != address(0x0), \\\"ServiceRegistry at address zero\\\");\\n        require(_udc_address != address(0x0), \\\"UDC at address zero\\\");\\n        require(contractExists(_token_address), \\\"token has no code\\\");\\n        require(contractExists(_service_registry_address), \\\"ServiceRegistry has no code\\\");\\n        require(contractExists(_udc_address), \\\"UDC has no code\\\");\\n        require(contractExists(_token_network_registry_address), \\\"TokenNetworkRegistry has no code\\\");\\n\\n        token = Token(_token_address);\\n        service_registry = ServiceRegistry(_service_registry_address);\\n        user_deposit = UserDeposit(_udc_address);\\n        token_network_registry = TokenNetworkRegistry(_token_network_registry_address);\\n        // Check if the contract is indeed a token contract\\n        require(token.totalSupply() > 0, \\\"Token with zero total supply\\\");\\n        // Check if the contract is indeed a service_registry contract\\n        // TODO: Check that some function exists in the contract\\n    }\\n\\n    /// @notice Internal function that updates the Reward struct if a newer balance proof\\n    /// is provided in the monitor() function\\n    /// @param token_network_address Address of the TokenNetwork being monitored\\n    /// @param closing_participant The address of the participant who closed the channel\\n    /// @param non_closing_participant Address of the other channel participant. This is\\n    /// the participant on whose behalf the MS acts.\\n    /// @param reward_amount The amount of tokens to be rewarded\\n    /// @param nonce The nonce of the newly provided balance_proof\\n    /// @param monitoring_service_address The address of the MS calling monitor()\\n    /// @param non_closing_signature Non-closing participant signature of the\\n    /// balance proof data.\\n    /// @param reward_proof_signature The signature of the signed reward proof\\n    function updateReward(\\n        address token_network_address,\\n        address closing_participant,\\n        address non_closing_participant,\\n        uint256 reward_amount,\\n        uint256 nonce,\\n        address monitoring_service_address,\\n        bytes memory non_closing_signature,\\n        bytes memory reward_proof_signature\\n    )\\n        internal\\n    {\\n        TokenNetwork token_network = TokenNetwork(token_network_address);\\n        address token_network_token = address(token_network.token());\\n        require(\\n            token_network_registry.token_to_token_networks(token_network_token) ==\\n            address(token_network),\\n            \\\"Unknown TokenNetwork\\\"\\n        );\\n        uint256 channel_identifier = token_network.getChannelIdentifier(\\n            closing_participant, non_closing_participant\\n        );\\n\\n        // Make sure that the reward proof is signed by the non_closing_participant\\n        address raiden_node_address = recoverAddressFromRewardProof(\\n            token_network.chain_id(),\\n            token_network_address,\\n            non_closing_participant,\\n            non_closing_signature,\\n            reward_amount,\\n            reward_proof_signature\\n        );\\n        require(raiden_node_address == non_closing_participant, \\\"Bad reward proof\\\");\\n\\n        bytes32 reward_identifier = keccak256(\\n            abi.encodePacked(\\n                channel_identifier,\\n                token_network_address\\n            )\\n        );\\n\\n        // Get the Reward struct for the correct channel\\n        Reward storage reward = rewards[reward_identifier];\\n\\n        // Only allow BPs with higher nonce to be submitted\\n        require(reward.nonce < nonce, \\\"stale nonce\\\");\\n\\n        // MSC stores channel_identifier, MS_address, reward_amount, nonce\\n        // of the MS that provided the balance_proof with highest nonce\\n        rewards[reward_identifier] = Reward({\\n            reward_amount: reward_amount,\\n            nonce: nonce,\\n            reward_sender_address: non_closing_participant,\\n            monitoring_service_address: monitoring_service_address\\n        });\\n    }\\n\\n    /// @notice Called by a registered MS, when providing a new balance proof\\n    /// to a monitored channel.\\n    /// Can be called multiple times by different registered MSs as long as the BP provided\\n    /// is newer than the current newest registered BP.\\n    /// @param nonce Strictly monotonic value used to order BPs\\n    /// omitting PB specific params, since these will not be provided in the future\\n    /// @param reward_amount Amount of tokens to be rewarded\\n    /// @param token_network_address Address of the Token Network in which the channel\\n    /// being monitored exists.\\n    /// @param reward_proof_signature The signature of the signed reward proof\\n    function monitor(\\n        address closing_participant,\\n        address non_closing_participant,\\n        bytes32 balance_hash,\\n        uint256 nonce,\\n        bytes32 additional_hash,\\n        bytes memory closing_signature,\\n        bytes memory non_closing_signature,\\n        uint256 reward_amount,\\n        address token_network_address,\\n        bytes memory reward_proof_signature\\n    )\\n        public\\n    {\\n        // Here we're trying to do bookkeeping first, but updateReward() first calls\\n        // token_network_address.  So reentrancy is possible.\\n        // In that case, the outer frame fails and reverts the state\\n        // because token_network_address is not registered in the token_network_registry.\\n        //\\n        // Maybe it's simpler and safer to take the token address as an argument instead,\\n        // and ask the TokenNetworkRegistry for the token_network_address.\\n        updateReward(\\n            token_network_address,\\n            closing_participant,\\n            non_closing_participant,\\n            reward_amount,\\n            nonce,\\n            msg.sender,\\n            non_closing_signature,\\n            reward_proof_signature\\n        );\\n\\n        TokenNetwork token_network = TokenNetwork(token_network_address);\\n        uint256 channel_identifier = token_network.getChannelIdentifier(\\n            closing_participant, non_closing_participant\\n        );\\n        require(\\n            block.number >= firstBlockAllowedToMonitorChannel(\\n                token_network,\\n                channel_identifier,\\n                closing_participant,\\n                non_closing_participant,\\n                msg.sender\\n            ),\\n            \\\"not allowed to monitor\\\"\\n        );\\n\\n        // Call updateTransfer in the corresponding TokenNetwork\\n        token_network.updateNonClosingBalanceProof(\\n            channel_identifier,\\n            closing_participant,\\n            non_closing_participant,\\n            balance_hash,\\n            nonce,\\n            additional_hash,\\n            closing_signature,\\n            non_closing_signature\\n        );\\n\\n        emit NewBalanceProofReceived(\\n            token_network_address,\\n            channel_identifier,\\n            reward_amount,\\n            nonce,\\n            msg.sender,\\n            non_closing_participant\\n        );\\n    }\\n\\n    function firstBlockAllowedToMonitorChannel(\\n        TokenNetwork token_network,\\n        uint256 channel_identifier,\\n        address closing_participant,\\n        address non_closing_participant,\\n        address monitoring_service_address\\n    )\\n        public view\\n        returns (uint256)\\n    {\\n        require(service_registry.hasValidRegistration(monitoring_service_address), \\\"service not registered\\\");\\n\\n        TokenNetwork.ChannelState channel_state;\\n        uint256 settle_block_number;\\n        (settle_block_number, channel_state) = token_network.getChannelInfo(\\n            channel_identifier, closing_participant, non_closing_participant\\n        );\\n        require(channel_state == TokenNetwork.ChannelState.Closed, \\\"channel not closed\\\");\\n\\n        // We don't actually know when the channel has been closed. So we'll\\n        // make a guess so that assumed_close_block >= real_close_block.\\n        uint256 assumed_settle_timeout = token_network.settlement_timeout_min();\\n        require(settle_block_number >= assumed_settle_timeout, \\\"too low settle block number\\\");\\n        uint256 assumed_close_block = settle_block_number - assumed_settle_timeout;\\n\\n        return firstBlockAllowedToMonitor(\\n            assumed_close_block,\\n            assumed_settle_timeout,\\n            closing_participant,\\n            non_closing_participant,\\n            monitoring_service_address\\n        );\\n    }\\n\\n    function firstBlockAllowedToMonitor(\\n        uint256 closed_at_block,\\n        uint256 settle_timeout,\\n        address participant1,\\n        address participant2,\\n        address monitoring_service_address\\n    )\\n        public pure\\n        returns (uint256)\\n    {\\n        // avoid overflows when multiplying with percentages\\n        require(settle_timeout < uint256(2**256 - 1) / 100, \\\"maliciously big settle timeout\\\");\\n        require(closed_at_block < uint256(2**256 - 1) / 100, \\\"maliciously big closed_at_block\\\");\\n\\n        // First allowed block as percentage of settle_timeout. We're using\\n        // integers here to avoid accuracy loss during calculations.\\n        uint256 BEST_CASE = 30;\\n        uint256 WORST_CASE = 80;\\n\\n        // When is the first block that any MS might be allowed to monitor\\n        uint256 best_case_block = closed_at_block + BEST_CASE * settle_timeout / 100;\\n        // Length of the range into which the first allowed block will fall\\n        uint256 range_length = (WORST_CASE - BEST_CASE) * settle_timeout / 100;\\n\\n        // Offset for this specific MS within the range\\n        uint256 ms_offset = (\\n            uint256(participant1) +\\n            uint256(participant2) +\\n            uint256(monitoring_service_address)\\n        ) % range_length;\\n\\n        return best_case_block + ms_offset;\\n    }\\n\\n    /// @notice Called after a monitored channel is settled in order for MS to claim the reward\\n    /// Can be called once per settled channel by everyone on behalf of MS\\n    /// @param token_network_address Address of the Token Network in which the channel exists\\n    /// @param closing_participant Address of the participant of the channel that called close\\n    /// @param non_closing_participant The other participant of the channel\\n    function claimReward(\\n        uint256 channel_identifier,\\n        address token_network_address,\\n        address closing_participant,\\n        address non_closing_participant\\n    )\\n        public\\n        returns (bool)\\n    {\\n        TokenNetwork token_network = TokenNetwork(token_network_address);\\n        bytes32 reward_identifier = keccak256(\\n            abi.encodePacked(\\n                channel_identifier,\\n                token_network_address\\n            )\\n        );\\n\\n        // Only allowed to claim, if channel is settled\\n        // Channel is settled if it's data has been deleted\\n        TokenNetwork.ChannelState channel_state;\\n        uint256 settle_block_number;\\n        (settle_block_number, channel_state) = token_network.getChannelInfo(\\n            channel_identifier,\\n            closing_participant,\\n            non_closing_participant\\n        );\\n        // We are trying to figure out when the settlement period ends.\\n        // The meaning of settle_block_number is totally different depending on channel_state.\\n        // When channel_state is NonExistent, settle_block_number is zero so it's not useful.\\n        // When channel_state is Open, settle_block_number is the length of the settlement period.\\n        // In these cases, we don't want to proceed anyway because the settlement period has not even started.\\n        // We can only proceed with these other channel states.\\n        require(\\n            channel_state == TokenNetwork.ChannelState.Closed ||\\n            channel_state == TokenNetwork.ChannelState.Settled ||\\n            channel_state == TokenNetwork.ChannelState.Removed, \\\"too early channel state\\\"\\n        );\\n        require(settle_block_number < block.number, \\\"channel not settled yet\\\");\\n\\n        Reward storage reward = rewards[reward_identifier];\\n\\n        // Make sure that the Reward exists\\n        require(reward.reward_sender_address != address(0x0), \\\"reward_sender is zero\\\");\\n\\n        // Add reward to the monitoring service's balance\\n        require(\\n            user_deposit.transfer(\\n                reward.reward_sender_address,\\n                reward.monitoring_service_address,\\n                reward.reward_amount\\n            ),\\n            \\\"UDC did not transfer\\\"\\n        );\\n\\n        emit RewardClaimed(\\n            reward.monitoring_service_address,\\n            reward.reward_amount,\\n            reward_identifier\\n        );\\n\\n        // delete storage\\n        delete rewards[reward_identifier];\\n\\n        return true;\\n    }\\n\\n    function recoverAddressFromRewardProof(\\n        uint256 chain_id,\\n        address token_network_address,\\n        address non_closing_participant,\\n        bytes memory non_closing_signature,\\n        uint256 reward_amount,\\n        bytes memory signature\\n    )\\n        internal\\n        view\\n        returns (address signature_address)\\n    {\\n        // This message shows the intention of the signer to pay\\n        // a reward to a Monitoring Service, provided that the\\n        // call of updateNonClosingBalanceProof() succeeds.\\n        // The triple (non_closing_participant, non_closing_signature, token_network_address)\\n        // uniquely identifies the call that's supposed to be made.\\n        // (Just checking non_closing_signature is not enough because\\n        // when an attacker tampers with the payload, the signature\\n        // verification doesn't fail but emits a different address.)\\n        // (Without a token_network, there will be some ambiguity\\n        // what the payload means.)\\n        bytes32 message_hash = keccak256(\\n            abi.encodePacked(\\n                \\\"\\\\x19Ethereum Signed Message:\\\\n221\\\",  // 20 + 32 + 32 + 20 + 20 + 65 + 32\\n                address(this),\\n                chain_id,\\n                uint256(MessageType.MessageTypeId.MSReward),\\n                token_network_address,\\n                non_closing_participant,\\n                non_closing_signature,\\n                reward_amount\\n            )\\n        );\\n\\n        signature_address = ECVerify.ecverify(message_hash, signature);\\n        require(signature_address == non_closing_participant, \\\"Reward proof with wrong non_closing_participant\\\");\\n    }\\n}\\n\\n\\n// MIT License\\n\\n// Copyright (c) 2018\\n\\n// Permission is hereby granted, free of charge, to any person obtaining a copy\\n// of this software and associated documentation files (the \\\"Software\\\"), to deal\\n// in the Software without restriction, including without limitation the rights\\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n// copies of the Software, and to permit persons to whom the Software is\\n// furnished to do so, subject to the following conditions:\\n\\n// The above copyright notice and this permission notice shall be included in all\\n// copies or substantial portions of the Software.\\n\\n// THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n// SOFTWARE.\",\"keccak256\":\"0x56bffc63caf9f965a3ec7d7ec9081c4c010f7a3dd725e3e5b13f3a189936dade\",\"license\":\"MIT\"},\"data/source/services/ServiceRegistry.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n/* solium-disable indentation */\\n/* solium-disable security/no-block-members */\\npragma solidity 0.7.6;\\n\\nimport \\\"../raiden/Token.sol\\\";\\nimport \\\"../raiden/Utils.sol\\\";\\n\\ncontract ServiceRegistryConfigurableParameters {\\n    address public controller;\\n\\n    modifier onlyController() {\\n        require(msg.sender == controller, \\\"caller is not the controller\\\");\\n        _;\\n    }\\n\\n    // After a price is set to set_price at timestamp set_price_at,\\n    // the price decays according to decayedPrice().\\n    uint256 public set_price;\\n    uint256 public set_price_at;\\n\\n    /// The amount of time (in seconds) till the price decreases to roughly 1/e.\\n    uint256 public decay_constant = 200 days;\\n\\n    // Once the price is at min_price, it can't decay further.\\n    uint256 public min_price = 1000;\\n\\n    // Whenever a deposit comes in, the price is multiplied by numerator / denominator.\\n    uint256 public price_bump_numerator = 1;\\n    uint256 public price_bump_denominator = 1;\\n\\n    // The duration of service registration/extension in seconds\\n    uint256 public registration_duration = 180 days;\\n\\n    // If true, new deposits are no longer accepted.\\n    bool public deprecated = false;\\n\\n    function setDeprecationSwitch() public onlyController returns (bool _success) {\\n        deprecated = true;\\n        return true;\\n    }\\n\\n    function changeParameters(\\n            uint256 _price_bump_numerator,\\n            uint256 _price_bump_denominator,\\n            uint256 _decay_constant,\\n            uint256 _min_price,\\n            uint256 _registration_duration\\n    ) public onlyController returns (bool _success) {\\n        changeParametersInternal(\\n            _price_bump_numerator,\\n            _price_bump_denominator,\\n            _decay_constant,\\n            _min_price,\\n            _registration_duration\\n        );\\n        return true;\\n    }\\n\\n    function changeParametersInternal(\\n            uint256 _price_bump_numerator,\\n            uint256 _price_bump_denominator,\\n            uint256 _decay_constant,\\n            uint256 _min_price,\\n            uint256 _registration_duration\\n    ) internal {\\n        refreshPrice();\\n        setPriceBumpParameters(_price_bump_numerator, _price_bump_denominator);\\n        setMinPrice(_min_price);\\n        setDecayConstant(_decay_constant);\\n        setRegistrationDuration(_registration_duration);\\n    }\\n\\n    // Updates set_price to be currentPrice() and set_price_at to be now\\n    function refreshPrice() private {\\n        set_price = currentPrice();\\n        set_price_at = block.timestamp;\\n    }\\n\\n    function setPriceBumpParameters(\\n            uint256 _price_bump_numerator,\\n            uint256 _price_bump_denominator\\n    ) private {\\n        require(_price_bump_denominator > 0, \\\"divide by zero\\\");\\n        require(_price_bump_numerator >= _price_bump_denominator, \\\"price dump instead of bump\\\");\\n        require(_price_bump_numerator < 2 ** 40, \\\"price dump numerator is too big\\\");\\n        price_bump_numerator = _price_bump_numerator;\\n        price_bump_denominator = _price_bump_denominator;\\n    }\\n\\n    function setMinPrice(uint256 _min_price) private {\\n        // No checks.  Even allowing zero.\\n        min_price = _min_price;\\n        // No checks or modifications on set_price.\\n        // Even if set_price is smaller than min_price, currentPrice() function returns min_price.\\n    }\\n\\n    function setDecayConstant(uint256 _decay_constant) private {\\n        require(_decay_constant > 0, \\\"attempt to set zero decay constant\\\");\\n        require(_decay_constant < 2 ** 40, \\\"too big decay constant\\\");\\n        decay_constant = _decay_constant;\\n    }\\n\\n    function setRegistrationDuration(uint256 _registration_duration) private {\\n        // No checks.  Even allowing zero (when no new registrations are possible).\\n        registration_duration = _registration_duration;\\n    }\\n\\n\\n    /// @notice The amount to deposit for registration or extension\\n    /// Note: the price moves quickly depending on what other addresses do.\\n    /// The current price might change after you send a `deposit()` transaction\\n    /// before the transaction is executed.\\n    function currentPrice() public view returns (uint256) {\\n        require(block.timestamp >= set_price_at, \\\"An underflow in price computation\\\");\\n        uint256 seconds_passed = block.timestamp - set_price_at;\\n\\n        return decayedPrice(set_price, seconds_passed);\\n    }\\n\\n\\n    /// @notice Calculates the decreased price after a number of seconds\\n    /// @param _set_price The initial price\\n    /// @param _seconds_passed The number of seconds passed since the initial\\n    /// price was set\\n    function decayedPrice(uint256 _set_price, uint256 _seconds_passed) public\\n        view returns (uint256) {\\n        // We are here trying to approximate some exponential decay.\\n        // exp(- X / A) where\\n        //   X is the number of seconds since the last price change\\n        //   A is the decay constant (A = 200 days corresponds to 0.5% decrease per day)\\n\\n        // exp(- X / A) ~~ P / Q where\\n        //   P = 24 A^4\\n        //   Q = 24 A^4 + 24 A^3X + 12 A^2X^2 + 4 AX^3 + X^4\\n        // Note: swap P and Q, and then think about the Taylor expansion.\\n\\n        uint256 X = _seconds_passed;\\n\\n        if (X >= 2 ** 40) { // The computation below overflows.\\n            return min_price;\\n        }\\n\\n        uint256 A = decay_constant;\\n\\n        uint256 P = 24 * (A ** 4);\\n        uint256 Q = P + 24*(A**3)*X + 12*(A**2)*(X**2) + 4*A*(X**3) + X**4;\\n\\n        // The multiplication below is not supposed to overflow because\\n        // _set_price should be at most 2 ** 90 and\\n        // P should be at most 24 * (2 ** 40).\\n        uint256 price = _set_price * P / Q;\\n\\n        // Not allowing a price smaller than min_price.\\n        // Once it's too low it's too low forever.\\n        if (price < min_price) {\\n            price = min_price;\\n        }\\n        return price;\\n    }\\n}\\n\\n\\ncontract Deposit {\\n    // This contract holds ERC20 tokens as deposit until a predetemined point of time.\\n\\n    // The ERC20 token contract that the deposit is about.\\n    Token public token;\\n\\n    // The address of ServiceRegistry contract that this deposit is associated with.\\n    // If the address has no code, service_registry.deprecated() call will fail.\\n    ServiceRegistryConfigurableParameters service_registry;\\n\\n    // The address that can withdraw the deposit after the release time.\\n    address public withdrawer;\\n\\n    // The timestamp after which the withdrawer can withdraw the deposit.\\n    uint256 public release_at;\\n\\n    /// @param _token The address of the ERC20 token contract where the deposit is accounted\\n    /// @param _release_at The timestap after which the withdrawer can withdraw the deposit\\n    /// @param _withdrawer The address that can withdraw the deposit after the release time\\n    /// @param _service_registry The address of ServiceRegistry whose deprecation enables immediate withdrawals\\n    constructor(\\n        Token _token,\\n        uint256 _release_at,\\n        address _withdrawer,\\n        ServiceRegistryConfigurableParameters _service_registry\\n    ) {\\n        token = _token;\\n        // Don't care even if it's in the past.\\n        release_at = _release_at;\\n        withdrawer = _withdrawer;\\n        service_registry = _service_registry;\\n    }\\n\\n    // In order to make a deposit, transfer the ERC20 token into this contract.\\n    // If you transfer a wrong kind of ERC20 token or ETH into this contract,\\n    // these tokens will be lost forever.\\n\\n    /// @notice Withdraws the tokens that have been deposited\\n    /// Only `withdrawer` can call this.\\n    /// @param _to The address where the withdrawn tokens should go\\n    function withdraw(address payable _to) external {\\n        uint256 balance = token.balanceOf(address(this));\\n        require(msg.sender == withdrawer, \\\"the caller is not the withdrawer\\\");\\n        require(block.timestamp >= release_at || service_registry.deprecated(), \\\"deposit not released yet\\\");\\n        require(balance > 0, \\\"nothing to withdraw\\\");\\n        require(token.transfer(_to, balance), \\\"token didn't transfer\\\");\\n        //selfdestruct(_to); // OVM does not support selfdestruct\\n    }\\n}\\n\\n\\ncontract ServiceRegistry is Utils, ServiceRegistryConfigurableParameters {\\n    Token public token;\\n\\n    mapping(address => uint256) public service_valid_till;\\n    mapping(address => string) public urls;  // URLs of services for HTTP access\\n\\n    // An append-only list of addresses that have ever made a deposit.\\n    // Starting from this list, all alive registrations can be figured out.\\n    address[] public ever_made_deposits;\\n\\n    // @param service The address of the registered service provider\\n    // @param valid_till The timestamp of the moment when the registration expires\\n    // @param deposit_amount The amount of deposit transferred\\n    // @param deposit The address of Deposit instance where the deposit is stored\\n    event RegisteredService(address indexed service, uint256 valid_till, uint256 deposit_amount, Deposit deposit_contract);\\n\\n    // @param _token_for_registration The address of the ERC20 token contract that services use for registration fees\\n    // @param _controller The address that can change parameters and deprecate the ServiceRegistry\\n    // @param _initial_price The amount of tokens needed initially for a slot\\n    // @param _price_bump_numerator The ratio of price bump after deposit is made (numerator)\\n    // @param _price_bump_denominator The ratio of price bump after deposit is made (denominator)\\n    // @param _decay_constant The number of seconds after which the price becomes roughly 1/e\\n    // @param _min_price The minimum amount of tokens needed for a slot\\n    // @param _registration_duration The number of seconds (roughly, barring block time & miners'\\n    // timestamp errors) of a slot gained for a successful deposit\\n    constructor(\\n            Token _token_for_registration,\\n            address _controller,\\n            uint256 _initial_price,\\n            uint256 _price_bump_numerator,\\n            uint256 _price_bump_denominator,\\n            uint256 _decay_constant,\\n            uint256 _min_price,\\n            uint256 _registration_duration\\n    ) {\\n        require(address(_token_for_registration) != address(0x0), \\\"token at address zero\\\");\\n        require(contractExists(address(_token_for_registration)), \\\"token has no code\\\");\\n        require(_initial_price >= min_price, \\\"initial price too low\\\");\\n        require(_initial_price <= 2 ** 90, \\\"intiial price too high\\\");\\n\\n        token = _token_for_registration;\\n        // Check if the contract is indeed a token contract\\n        require(token.totalSupply() > 0, \\\"total supply zero\\\");\\n        controller = _controller;\\n\\n        // Set up the price and the set price timestamp\\n        set_price = _initial_price;\\n        set_price_at = block.timestamp;\\n\\n        // Set the parameters\\n        changeParametersInternal(_price_bump_numerator, _price_bump_denominator, _decay_constant, _min_price, _registration_duration);\\n    }\\n\\n    // @notice Locks tokens and registers a service or extends the registration\\n    // @param _limit_amount The biggest amount of tokens that the caller is willing to deposit\\n    // The call fails if the current price is higher (this is always possible\\n    // when other parties have just called `deposit()`)\\n    function deposit(uint _limit_amount) public returns (bool _success) {\\n        require(! deprecated, \\\"this contract was deprecated\\\");\\n\\n        uint256 amount = currentPrice();\\n        require(_limit_amount >= amount, \\\"not enough limit\\\");\\n\\n        // Extend the service position.\\n        uint256 valid_till = service_valid_till[msg.sender];\\n        if (valid_till == 0) { // a first time joiner\\n            ever_made_deposits.push(msg.sender);\\n        }\\n        if (valid_till < block.timestamp) { // a first time joiner or an expired service.\\n            valid_till = block.timestamp;\\n        }\\n        // Check against overflow.\\n        require(valid_till < valid_till + registration_duration, \\\"overflow during extending the registration\\\");\\n        valid_till = valid_till + registration_duration;\\n        assert(valid_till > service_valid_till[msg.sender]);\\n        service_valid_till[msg.sender] = valid_till;\\n\\n        // Record the price\\n        set_price = amount * price_bump_numerator / price_bump_denominator;\\n        if (set_price > 2 ** 90) {\\n            set_price = 2 ** 90; // Preventing overflows.\\n        }\\n        set_price_at = block.timestamp;\\n\\n        // Move the deposit in a new Deposit contract.\\n        assert(block.timestamp < valid_till);\\n        Deposit depo = new Deposit(token, valid_till, msg.sender, this);\\n        require(token.transferFrom(msg.sender, address(depo), amount), \\\"Token transfer for deposit failed\\\");\\n\\n        // Fire event\\n        emit RegisteredService(msg.sender, valid_till, amount, depo);\\n\\n        return true;\\n    }\\n\\n    /// @notice Sets the URL used to access a service via HTTP\\n    /// Only a currently registered service can call this successfully\\n    /// @param new_url The new URL string to be stored\\n    function setURL(string memory new_url) public returns (bool _success) {\\n        require(hasValidRegistration(msg.sender), \\\"registration expired\\\");\\n        require(bytes(new_url).length != 0, \\\"new url is empty string\\\");\\n        urls[msg.sender] = new_url;\\n        return true;\\n    }\\n\\n    /// A getter function for seeing the length of ever_made_deposits array\\n    function everMadeDepositsLen() public view returns (uint256 _len) {\\n        return ever_made_deposits.length;\\n    }\\n\\n    function hasValidRegistration(address _address) public view returns (bool _has_registration) {\\n        return block.timestamp < service_valid_till[_address];\\n    }\\n}\\n\\n\\n// MIT License\\n\\n// Copyright (c) 2018\\n\\n// Permission is hereby granted, free of charge, to any person obtaining a copy\\n// of this software and associated documentation files (the \\\"Software\\\"), to deal\\n// in the Software without restriction, including without limitation the rights\\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n// copies of the Software, and to permit persons to whom the Software is\\n// furnished to do so, subject to the following conditions:\\n\\n// The above copyright notice and this permission notice shall be included in all\\n// copies or substantial portions of the Software.\\n\\n// THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n// SOFTWARE.\",\"keccak256\":\"0x5a967df24ca5e9bb01d0b5d550b6a420d6998831766e031686ca7bba11362bae\",\"license\":\"MIT\"},\"data/source/services/UserDeposit.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.6;\\n\\nimport \\\"../raiden/Token.sol\\\";\\nimport \\\"../raiden/Utils.sol\\\";\\n\\ncontract UserDeposit is Utils {\\n    uint constant public withdraw_delay = 100;  // time before withdraw is allowed in blocks\\n\\n    // Token to be used for the deposit\\n    Token public token;\\n\\n    // Trusted contracts (can execute `transfer`)\\n    address public msc_address;\\n    address public one_to_n_address;\\n\\n    // Total amount of tokens that have been deposited. This is monotonous and\\n    // doing a transfer or withdrawing tokens will not decrease total_deposit!\\n    mapping(address => uint256) public total_deposit;\\n    // Current user's balance, ignoring planned withdraws\\n    mapping(address => uint256) public balances;\\n    mapping(address => WithdrawPlan) public withdraw_plans;\\n\\n    // The sum of all balances\\n    uint256 public whole_balance = 0;\\n    // Deposit limit for this whole contract\\n    uint256 public whole_balance_limit;\\n\\n    /*\\n     *  Structs\\n     */\\n    struct WithdrawPlan {\\n        uint256 amount;\\n        uint256 withdraw_block;  // earliest block at which withdraw is allowed\\n    }\\n\\n    /*\\n     *  Events\\n     */\\n\\n    event BalanceReduced(address indexed owner, uint newBalance);\\n    event WithdrawPlanned(address indexed withdrawer, uint plannedBalance);\\n\\n    /*\\n     *  Modifiers\\n     */\\n\\n    modifier canTransfer() {\\n        require(msg.sender == msc_address || msg.sender == one_to_n_address, \\\"unknown caller\\\");\\n        _;\\n    }\\n\\n    /*\\n     *  Constructor\\n     */\\n\\n    /// @notice Set the default values for the smart contract\\n    /// @param _token_address The address of the token to use for rewards\\n    constructor(address _token_address, uint256 _whole_balance_limit)\\n    {\\n        // check token contract\\n        require(_token_address != address(0x0), \\\"token at address zero\\\");\\n        require(contractExists(_token_address), \\\"token has no code\\\");\\n        token = Token(_token_address);\\n        require(token.totalSupply() > 0, \\\"token has no total supply\\\"); // Check if the contract is indeed a token contract\\n        // check and set the whole balance limit\\n        require(_whole_balance_limit > 0, \\\"whole balance limit is zero\\\");\\n        whole_balance_limit = _whole_balance_limit;\\n    }\\n\\n    /// @notice Specify trusted contracts. This has to be done outside of the\\n    /// constructor to avoid cyclic dependencies.\\n    /// @param _msc_address Address of the MonitoringService contract\\n    /// @param _one_to_n_address Address of the OneToN contract\\n    function init(address _msc_address, address _one_to_n_address)\\n        external\\n    {\\n        // prevent changes of trusted contracts after initialization\\n        require(msc_address == address(0x0) && one_to_n_address == address(0x0), \\\"already initialized\\\");\\n\\n        // check monitoring service contract\\n        require(_msc_address != address(0x0), \\\"MS contract at address zero\\\");\\n        require(contractExists(_msc_address), \\\"MS contract has no code\\\");\\n        msc_address = _msc_address;\\n\\n        // check one to n contract\\n        require(_one_to_n_address != address(0x0), \\\"OneToN at address zero\\\");\\n        require(contractExists(_one_to_n_address), \\\"OneToN has no code\\\");\\n        one_to_n_address = _one_to_n_address;\\n    }\\n\\n    /// @notice Deposit tokens. The amount of transferred tokens will be\\n    /// `new_total_deposit - total_deposit[beneficiary]`. This makes the\\n    /// function behavior predictable and idempotent. Can be called several\\n    /// times and on behalf of other accounts.\\n    /// @param beneficiary The account benefiting from the deposit\\n    /// @param new_total_deposit The total sum of tokens that have been\\n    /// deposited by the user by calling this function.\\n    function deposit(address beneficiary, uint256 new_total_deposit)\\n        external\\n    {\\n        require(new_total_deposit > total_deposit[beneficiary], \\\"deposit not increasing\\\");\\n\\n        // Calculate the actual amount of tokens that will be transferred\\n        uint256 added_deposit = new_total_deposit - total_deposit[beneficiary];\\n\\n        balances[beneficiary] += added_deposit;\\n        total_deposit[beneficiary] += added_deposit;\\n\\n        // Update whole_balance, but take care against overflows.\\n        require(whole_balance + added_deposit >= whole_balance, \\\"overflowing deposit\\\");\\n        whole_balance += added_deposit;\\n\\n        // Decline deposit if the whole balance is bigger than the limit.\\n        require(whole_balance <= whole_balance_limit, \\\"too much deposit\\\");\\n\\n        // Actual transfer.\\n        require(token.transferFrom(msg.sender, address(this), added_deposit), \\\"tokens didn't transfer\\\");\\n    }\\n\\n    /// @notice Internally transfer deposits between two addresses.\\n    /// Sender and receiver must be different or the transaction will fail.\\n    /// @param sender Account from which the amount will be deducted\\n    /// @param receiver Account to which the amount will be credited\\n    /// @param amount Amount of tokens to be transferred\\n    /// @return success true if transfer has been done successfully, otherwise false\\n    function transfer(\\n        address sender,\\n        address receiver,\\n        uint256 amount\\n    )\\n        external\\n        canTransfer()\\n        returns (bool success)\\n    {\\n        require(sender != receiver, \\\"sender == receiver\\\");\\n        if (balances[sender] >= amount && amount > 0) {\\n            balances[sender] -= amount;\\n            balances[receiver] += amount;\\n            emit BalanceReduced(sender, balances[sender]);\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /// @notice Announce intention to withdraw tokens.\\n    /// Sets the planned withdraw amount and resets the withdraw_block.\\n    /// There is only one planned withdrawal at a time, the old one gets overwritten.\\n    /// @param amount Maximum amount of tokens to be withdrawn\\n    function planWithdraw(uint256 amount)\\n        external\\n    {\\n        require(amount > 0, \\\"withdrawing zero\\\");\\n        require(balances[msg.sender] >= amount, \\\"withdrawing too much\\\");\\n\\n        withdraw_plans[msg.sender] = WithdrawPlan({\\n            amount: amount,\\n            withdraw_block: block.number + withdraw_delay\\n        });\\n        emit WithdrawPlanned(msg.sender, balances[msg.sender] - amount);\\n    }\\n\\n    /// @notice Execute a planned withdrawal\\n    /// Will only work after the withdraw_delay has expired.\\n    /// An amount lower or equal to the planned amount may be withdrawn.\\n    /// Removes the withdraw plan even if not the full amount has been\\n    /// withdrawn.\\n    /// @param amount Amount of tokens to be withdrawn\\n    function withdraw(uint256 amount)\\n        external\\n    {\\n        WithdrawPlan storage withdraw_plan = withdraw_plans[msg.sender];\\n        require(amount <= withdraw_plan.amount, \\\"withdrawing more than planned\\\");\\n        require(withdraw_plan.withdraw_block <= block.number, \\\"withdrawing too early\\\");\\n        uint256 withdrawable = min(amount, balances[msg.sender]);\\n        balances[msg.sender] -= withdrawable;\\n\\n        // Update whole_balance, but take care against underflows.\\n        require(whole_balance - withdrawable <= whole_balance, \\\"underflow in whole_balance\\\");\\n        whole_balance -= withdrawable;\\n\\n        emit BalanceReduced(msg.sender, balances[msg.sender]);\\n        delete withdraw_plans[msg.sender];\\n\\n        require(token.transfer(msg.sender, withdrawable), \\\"tokens didn't transfer\\\");\\n    }\\n\\n    /// @notice The owner's balance with planned withdrawals deducted\\n    /// @param owner Address for which the balance should be returned\\n    /// @return remaining_balance The remaining balance after planned withdrawals\\n    function effectiveBalance(address owner)\\n        external\\n        view\\n        returns (uint256 remaining_balance)\\n    {\\n        WithdrawPlan storage withdraw_plan = withdraw_plans[owner];\\n        if (withdraw_plan.amount > balances[owner]) {\\n            return 0;\\n        }\\n        return balances[owner] - withdraw_plan.amount;\\n    }\\n\\n    function min(uint256 a, uint256 b) internal pure returns (uint256)\\n    {\\n        return a > b ? b : a;\\n    }\\n}\\n\\n\\n// MIT License\\n\\n// Copyright (c) 2018\\n\\n// Permission is hereby granted, free of charge, to any person obtaining a copy\\n// of this software and associated documentation files (the \\\"Software\\\"), to deal\\n// in the Software without restriction, including without limitation the rights\\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n// copies of the Software, and to permit persons to whom the Software is\\n// furnished to do so, subject to the following conditions:\\n\\n// The above copyright notice and this permission notice shall be included in all\\n// copies or substantial portions of the Software.\\n\\n// THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n// SOFTWARE.\",\"keccak256\":\"0x070b4f1949eec8099a1bc6e8a91789ba64853074e79b6a272d0bd8cc8f0e3053\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x60806040523480156200001c576000806200001962000554565b50505b506040516200251c3803806200251c833981810160405260808110156200004d576000806200004a62000554565b50505b810190808051929190602001805192919060200180519291906020018051925050506001600160a01b038416620000d55760405162461bcd60e51b815260206004820152601560248201527f546f6b656e2061742061646472657373207a65726f0000000000000000000000604482015260640160405180910390620000d262000554565b50505b6001600160a01b0383166200013b5760405162461bcd60e51b815260206004820152601f60248201527f5365727669636552656769737472792061742061646472657373207a65726f006044820152606401604051809103906200013862000554565b50505b6001600160a01b038216620001a15760405162461bcd60e51b815260206004820152601360248201527f5544432061742061646472657373207a65726f000000000000000000000000006044820152606401604051809103906200019e62000554565b50505b620001ac846200053d565b620001fc5760405162461bcd60e51b8152602060048201526011602482015270746f6b656e20686173206e6f20636f646560781b604482015260640160405180910390620001f962000554565b50505b62000207836200053d565b620002635760405162461bcd60e51b815260206004820152601b60248201527f53657276696365526567697374727920686173206e6f20636f646500000000006044820152606401604051809103906200026062000554565b50505b6200026e826200053d565b620002bc5760405162461bcd60e51b815260206004820152600f60248201526e55444320686173206e6f20636f646560881b604482015260640160405180910390620002b962000554565b50505b620002c7816200053d565b620003235760405162461bcd60e51b815260206004820181905260248201527f546f6b656e4e6574776f726b526567697374727920686173206e6f20636f64656044820152606401604051809103906200032062000554565b50505b83600060018162000333620005c1565b816001600160a01b0302191690836001600160a01b03160217906200035762000623565b50505082600160006101000a816200036e620005c1565b816001600160a01b0302191690836001600160a01b03160217906200039262000623565b50505081600260006101000a81620003a9620005c1565b816001600160a01b0302191690836001600160a01b0316021790620003cd62000623565b50505080600360006101000a81620003e4620005c1565b816001600160a01b0302191690836001600160a01b03160217906200040862000623565b5050506000806000906200041b620005c1565b906101000a90046001600160a01b03166001600160a01b03166318160ddd6040518163ffffffff1660e01b815260040160206040518083038186806200046062000672565b15801562000478576000806200047562000554565b50505b505a62000484620006bf565b5050505050158015620004a6573d6000803e3d6000620004a362000554565b50505b505050506040513d6020811015620004c857600080620004c562000554565b50505b810190808051939093119250620005339150505760405162461bcd60e51b815260206004820152601c60248201527f546f6b656e2077697468207a65726f20746f74616c20737570706c79000000006044820152606401604051809103906200053062000554565b50505b50505050620007b7565b600080826200054b62000672565b15159392505050565b632a2a7adb598160e01b8152600481016020815285602082015260005b868110156200058e57808601518282016040015260200162000571565b506020828760640184336000905af158600e01573d6000803e3d6000fd5b3d6001141558600a015760016000f35b505050565b6303daa959598160e01b8152836004820152602081602483336000905af158600e01573d6000803e3d6000fd5b3d6001141558600a015760016000f35b8051935060005b60408110156200061e5760008282015260200162000605565b505050565b6322bd64c0598160e01b8152836004820152846024820152600081604483336000905af158600e01573d6000803e3d6000fd5b3d6001141558600a015760016000f35b60008152602062000605565b638435035b598160e01b8152836004820152602081602483336000905af158600e01573d6000803e3d6000fd5b3d6001141558600a015760016000f35b8051600082529350602062000605565b638540661f598160e01b8152620006f5565b8080831115620006de5750815b92915050565b8080831015620006de575090919050565b836004820152846024820152606060448201528660648201526084810160005b888110156200072f57808801518282015260200162000715565b506060828960a40184336000905af158600e01573d6000803e3d6000fd5b3d6001141558600a015760016000f35b815160408301513d6000853e8b8b82606087013350600060045af15059620007868d3d620006e4565b8c01620007948187620006d1565b5b82811015620007ab576000815260200162000795565b50929c50505050505050565b611d5580620007c76000396000f3fe608060405234801561001957600080610016611963565b50505b506004361061008c5760003560e01c80630e7dfb731461009a57806360df33d8146100f5578063637d89d4146101565780636766923e1461017a5780637709bc78146101c757806381c6dac2146101f6578063b4238f4a146101fe578063d3b6c08014610206578063fc0c546a1461044f575b600080610097611963565b50505b6100e1600480360360808110156100b9576000806100b6611963565b50505b508035906001600160a01b036020820135811691604081013582169160609091013516610457565b604051901515815260200160405180910390f35b610144600480360360a081101561011457600080610111611963565b50505b506001600160a01b038135811691602081013591604082013581169160608101358216916080909101351661093e565b60405190815260200160405180910390f35b61015e610ca8565b6040516001600160a01b03909116815260200160405180910390f35b610144600480360360a081101561019957600080610196611963565b50505b508035906020810135906001600160a01b036040820135811691606081013582169160809091013516610cc7565b6100e1600480360360208110156101e6576000806101e3611963565b50505b50356001600160a01b0316610de1565b61015e610df6565b61015e610e02565b61044d600480360361014081101561022657600080610223611963565b50505b6001600160a01b0382358116926020810135909116916040820135916060810135916080820135919081019060c0810160a0820135600160201b81111561027557600080610272611963565b50505b8201836020820111156102905760008061028d611963565b50505b803590602001918460018302840111600160201b831117156102ba576000806102b7611963565b50505b91908080601f01602080910402602001604051908101604052818152929190602084018383808284376000920191909152509295949360208101935035915050600160201b81111561031457600080610311611963565b50505b82018360208201111561032f5760008061032c611963565b50505b803590602001918460018302840111600160201b8311171561035957600080610356611963565b50505b91908080601f016020809104026020016040519081016040528181529291906020840183838082843760009201919091525092958435956001600160a01b0360208701351695919450925060608101915060400135600160201b8111156103c8576000806103c5611963565b50505b8201836020820111156103e3576000806103e0611963565b50505b803590602001918460018302840111600160201b8311171561040d5760008061040a611963565b50505b91908080601f0160208091040260200160405190810160405281815292919060208401838380828437600092019190915250929550610e0e945050505050565b005b61015e611165565b60008381868260405160200180838152602001826001600160a01b031660601b815260140192505050604051602081830303815290604052805190602001209050600080836001600160a01b031663838d6e058a89896040516001600160e01b031960e086901b16815260048101939093526001600160a01b039182166024840152166044820152606401604080518083038186806104f46119ce565b15801561050957600080610506611963565b50505b505a610513611a2e565b5050505050158015610532573d6000803e3d600061052f611963565b50505b505050506040513d60408110156105515760008061054e611963565b50505b8101908080519291906020018051955092935060029250610570915050565b82600481111561057c57fe5b14806105935750600382600481111561059157fe5b145b806105a9575060048260048111156105a757fe5b145b6105fc5760405162461bcd60e51b8152602060048201526017602482015276746f6f206561726c79206368616e6e656c20737461746560481b6044820152606401604051809103906105f9611963565b50505b5a610605611b19565b811061065a5760405162461bcd60e51b815260206004820152601760248201527618da185b9b995b081b9bdd081cd95d1d1b1959081e595d604a1b604482015260640160405180910390610657611963565b50505b6000838152600460205260408120905060008060028301610679611b5f565b906101000a90046001600160a01b03166001600160a01b031614156106e55760405162461bcd60e51b81526020600482015260156024820152747265776172645f73656e646572206973207a65726f60581b6044820152606401604051809103906106e2611963565b50505b600060026106f1611b5f565b6001600160a01b036101009290920a90041663beabacc8600060028401610716611b5f565b906101000a90046001600160a01b031683600301600090610735611b5f565b906101000a90046001600160a01b031684600001610751611b5f565b6040516001600160e01b031960e086901b1681526001600160a01b03938416600482015291909216602482015260448101919091526064016020604051808303816000878061079e6119ce565b1580156107b3576000806107b0611963565b50505b505a6107bd611bab565b5050505050501580156107dd573d6000803e3d60006107da611963565b50505b505050506040513d60208110156107fc576000806107f9611963565b50505b81019080805192506108579150505760405162461bcd60e51b81526020600482015260146024820152732aa221903234b2103737ba103a3930b739b332b960611b604482015260640160405180910390610854611963565b50505b83600060038301610866611b5f565b6001600160a01b036101009290920a9004167fe413caa6d70a6d9b51c2af2575a2914490f614355049af8ae7cde5caab9fd201836108a2611b5f565b60405190815260200160405180910390a36000848152600460205260409020600080826108cd611c71565b5050600182016000906108de611c71565b5050600282016001816108ef611b5f565b906001600160a01b0302191690610904611c71565b505060038201600181610915611b5f565b906001600160a01b030219169061092a611c71565b5060019d9c50505050505050505050505050565b600080600161094b611b5f565b906101000a90046001600160a01b03166001600160a01b031663ebc00c05836040516001600160e01b031960e084901b1681526001600160a01b03909116600482015260240160206040518083038186806109a46119ce565b1580156109b9576000806109b6611963565b50505b505a6109c3611a2e565b50505050501580156109e2573d6000803e3d60006109df611963565b50505b505050506040513d6020811015610a01576000806109fe611963565b50505b8101908080519250610a5e9150505760405162461bcd60e51b81526020600482015260166024820152751cd95c9d9a58d9481b9bdd081c9959da5cdd195c995960521b604482015260640160405180910390610a5b611963565b50505b600080876001600160a01b031663838d6e058888886040516001600160e01b031960e086901b16815260048101939093526001600160a01b03918216602484015216604482015260640160408051808303818680610aba6119ce565b158015610acf57600080610acc611963565b50505b505a610ad9611a2e565b5050505050158015610af8573d6000803e3d6000610af5611963565b50505b505050506040513d6040811015610b1757600080610b14611963565b50505b8101908080519291906020018051955092935060029250610b36915050565b826004811115610b4257fe5b14610b915760405162461bcd60e51b815260206004820152601260248201527118da185b9b995b081b9bdd0818db1bdcd95960721b604482015260640160405180910390610b8e611963565b50505b6000886001600160a01b031663b8378f756040518163ffffffff1660e01b81526004016020604051808303818680610bc76119ce565b158015610bdc57600080610bd9611963565b50505b505a610be6611a2e565b5050505050158015610c05573d6000803e3d6000610c02611963565b50505b505050506040513d6020811015610c2457600080610c21611963565b50505b810190808051935050505080821015610c8a5760405162461bcd60e51b815260206004820152601b60248201527a3a37b7903637bb9039b2ba3a363290313637b1b590373ab6b132b960291b604482015260640160405180910390610c87611963565b50505b808203610c9a81838a8a8a610cc7565b9a9950505050505050505050565b60006002610cb4611b5f565b906101000a90046001600160a01b031681565b6000600080516020611d358339815191528510610d335760405162461bcd60e51b815260206004820152601e60248201527f6d616c6963696f75736c792062696720736574746c652074696d656f75740000604482015260640160405180910390610d30611963565b50505b600080516020611d358339815191528610610d9d5760405162461bcd60e51b815260206004820152601f60248201527f6d616c6963696f75736c792062696720636c6f7365645f61745f626c6f636b00604482015260640160405180910390610d9a611963565b50505b601e6050606487830281900489019060328902046000816001600160a01b038a81168a8216019089160181610dce57fe5b06929092019a9950505050505050505050565b60008082610ded6119ce565b15159392505050565b60006001610cb4611b5f565b60006003610cb4611b5f565b610e26828b8b868b5a610e1f611cbf565b8a88611170565b8160006001600160a01b03821663938bcd678d8d6040516001600160e01b031960e085901b1681526001600160a01b039283166004820152911660248201526044016020604051808303818680610e7b6119ce565b158015610e9057600080610e8d611963565b50505b505a610e9a611a2e565b5050505050158015610eb9573d6000803e3d6000610eb6611963565b50505b505050506040513d6020811015610ed857600080610ed5611963565b50505b8101908080519350610efb92508491508390508e8e5a610ef6611cbf565b61093e565b5a610f04611b19565b1015610f585760405162461bcd60e51b81526020600482015260166024820152753737ba1030b63637bbb2b2103a379036b7b734ba37b960511b604482015260640160405180910390610f55611963565b50505b816001600160a01b031663fadc554b828e8e8e8e8e8e8e6040518963ffffffff1660e01b815260040180898152602001886001600160a01b03168152602001876001600160a01b031681526020018681526020018581526020018481526020018060200180602001838103835285818151815260200191508051906020019080838360005b83811015610ff5578082015183820152602001610fdd565b50505050905090810190601f1680156110225780820380516001836020036101000a031916815260200191505b50838103825284818151815260200191508051906020019080838360005b83811015611058578082015183820152602001611040565b50505050905090810190601f1680156110855780820380516001836020036101000a031916815260200191505b509a5050505050505050505050600060405180830381600087806110a76119ce565b1580156110bc576000806110b9611963565b50505b505a6110c6611bab565b5050505050501580156110e6573d6000803e3d60006110e3611963565b50505b505050508a6001600160a01b03165a6110fd611cbf565b6001600160a01b03168a7f486d5933a2980e097e7c32c7fe217158facf1a3973bac8235ac6c8b0e77d3dff87858a60405180846001600160a01b03168152602001838152602001828152602001935050505060405180910390a4505050505050505050505050565b600080610cb4611b5f565b8760006001600160a01b03821663fc0c546a6040518163ffffffff1660e01b815260040160206040518083038186806111a76119ce565b1580156111bc576000806111b9611963565b50505b505a6111c6611a2e565b50505050501580156111e5573d6000803e3d60006111e2611963565b50505b505050506040513d602081101561120457600080611201611963565b50505b810190808051935050506001600160a01b038316905060006003611226611b5f565b906101000a90046001600160a01b03166001600160a01b0316630fabd9e7836040516001600160e01b031960e084901b1681526001600160a01b039091166004820152602401602060405180830381868061127f6119ce565b15801561129457600080611291611963565b50505b505a61129e611a2e565b50505050501580156112bd573d6000803e3d60006112ba611963565b50505b505050506040513d60208110156112dc576000806112d9611963565b50505b8101908080516001600160a01b03169390931492506113449150505760405162461bcd60e51b8152602060048201526014602482015273556e6b6e6f776e20546f6b656e4e6574776f726b60601b604482015260640160405180910390611341611963565b50505b6000826001600160a01b031663938bcd678b8b6040516001600160e01b031960e085901b1681526001600160a01b0392831660048201529116602482015260440160206040518083038186806113986119ce565b1580156113ad576000806113aa611963565b50505b505a6113b7611a2e565b50505050501580156113d6573d6000803e3d60006113d3611963565b50505b505050506040513d60208110156113f5576000806113f2611963565b50505b8101908080519350600092506114ae9150506001600160a01b038516633af973b16040518163ffffffff1660e01b8152600401602060405180830381868061143b6119ce565b1580156114505760008061144d611963565b50505b505a61145a611a2e565b5050505050158015611479573d6000803e3d6000611476611963565b50505b505050506040513d602081101561149857600080611495611963565b50505b81019080805192508f91508d9050898d8a6116a0565b9050896001600160a01b0316816001600160a01b0316146115115760405162461bcd60e51b815260206004820152601060248201526f2130b2103932bbb0b93210383937b7b360811b60448201526064016040518091039061150e611963565b50505b6000828d60405160200180838152602001826001600160a01b031660601b8152601401925050506040516020818303038152906040528051906020012060008181526004602052909150604081209050898160010161156e611b5f565b106115b65760405162461bcd60e51b815260206004820152600b60248201526a7374616c65206e6f6e636560a81b6044820152606401604051809103906115b3611963565b50505b60405180608001604052808c81526020018b81526020018d6001600160a01b031681526020018a6001600160a01b031681525060046000848152602001908152602001600020815181611607611c71565b505060208201518160010161161a611c71565b5050604082015160028201600181611630611b5f565b816001600160a01b0302191690836001600160a01b0316021790611652611c71565b505050606082015160038201600181611669611b5f565b816001600160a01b0302191690836001600160a01b031602179061168b611c71565b50505050505050505050505050505050505050565b6000805a63996d79a5598160e01b8152602081600483336000905af158600e01573d6000803e3d6000fd5b3d6001141558600a015760016000f35b8051925060005b60408110156116f9576000828201526020016116e2565b508a9150600690508989898960405160200180807f19457468657265756d205369676e6564204d6573736167653a0a323231000000815250601d01886001600160a01b031660601b8152601401878152602001868152602001856001600160a01b031660601b8152601401846001600160a01b031660601b815260140183805190602001908083835b602083106117a15780518252601f199092019160209182019101611782565b6001836020036101000a038019825116818451161790925250505091909101928352505060200195506040945050505050516020818303038152906040528051906020012090506117f28184611858565b9150856001600160a01b0316826001600160a01b03161461184d5760405162461bcd60e51b815260040180806020018281038252602f815260200180611d06602f91396040019150506040518091039061184a611963565b50505b509695505050505050565b600081516041146118715760008061186e611963565b50505b60008060006020850151925060408501519150606085015160001a9050601b81101561189b57601b015b8060ff16601b14806118b057508060ff16601c145b6118c2576000806118bf611963565b50505b60018682858560405160008152602001604052604051808581526020018460ff1681526020018381526020018281526020019450505050506020604051602081039080840390855a611912611a2e565b5050505050158015611931573d6000803e3d600061192e611963565b50505b5050506020604051035193506001600160a01b03841661195957600080611956611963565b50505b5050505b92915050565b632a2a7adb598160e01b8152600481016020815285602082015260005b8681101561199b578086015182820160400152602001611980565b506020828760640184336000905af158600e01573d6000803e3d6000fd5b3d6001141558600a015760016000f35b505050565b638435035b598160e01b8152836004820152602081602483336000905af158600e01573d6000803e3d6000fd5b3d6001141558600a015760016000f35b8051935060005b6040811015611a2957600082820152602001611a12565b505050565b638540661f598160e01b8152611a5f565b808083111561195d575090919050565b808083101561195d575090919050565b836004820152846024820152606060448201528660648201526084810160005b88811015611a97578088015182820152602001611a7f565b506060828960a40184336000905af158600e01573d6000803e3d6000fd5b3d6001141558600a015760016000f35b815160408301513d6000853e8b8b82606087013350600060045af15059611aec8d3d611a4f565b8c01611af88187611a3f565b5b82811015611b0d5760008152602001611af9565b50929c50505050505050565b635a98c361598160e01b8152602081600483336000905af158600e01573d6000803e3d6000fd5b3d6001141558600a015760016000f35b80516000825293506020611a12565b6303daa959598160e01b8152836004820152602081602483336000905af158600e01573d6000803e3d6000fd5b3d6001141558600a015760016000f35b80516000825293506020611a12565b6385979f76598160e01b8152836004820152846024820152606060448201528760648201526084810160005b89811015611bef578089015182820152602001611bd7565b506060828a60a40184336000905af158600e01573d6000803e3d6000fd5b3d6001141558600a015760016000f35b815160408301513d6000853e8c8c82606087013350600060045af15059611c448e3d611a4f565b8d01611c508187611a3f565b5b82811015611c655760008152602001611c51565b50929d50505050505050565b6322bd64c0598160e01b8152836004820152846024820152600081604483336000905af158600e01573d6000803e3d6000fd5b3d6001141558600a015760016000f35b600081526020611a12565b6373509064598160e01b8152602081600483336000905af158600e01573d6000803e3d6000fd5b3d6001141558600a015760016000f35b80516000825293506020611a1256fe5265776172642070726f6f6620776974682077726f6e67206e6f6e5f636c6f73696e675f7061727469636970616e74028f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f",
  "deployedBytecode": "0x608060405234801561001957600080610016611963565b50505b506004361061008c5760003560e01c80630e7dfb731461009a57806360df33d8146100f5578063637d89d4146101565780636766923e1461017a5780637709bc78146101c757806381c6dac2146101f6578063b4238f4a146101fe578063d3b6c08014610206578063fc0c546a1461044f575b600080610097611963565b50505b6100e1600480360360808110156100b9576000806100b6611963565b50505b508035906001600160a01b036020820135811691604081013582169160609091013516610457565b604051901515815260200160405180910390f35b610144600480360360a081101561011457600080610111611963565b50505b506001600160a01b038135811691602081013591604082013581169160608101358216916080909101351661093e565b60405190815260200160405180910390f35b61015e610ca8565b6040516001600160a01b03909116815260200160405180910390f35b610144600480360360a081101561019957600080610196611963565b50505b508035906020810135906001600160a01b036040820135811691606081013582169160809091013516610cc7565b6100e1600480360360208110156101e6576000806101e3611963565b50505b50356001600160a01b0316610de1565b61015e610df6565b61015e610e02565b61044d600480360361014081101561022657600080610223611963565b50505b6001600160a01b0382358116926020810135909116916040820135916060810135916080820135919081019060c0810160a0820135600160201b81111561027557600080610272611963565b50505b8201836020820111156102905760008061028d611963565b50505b803590602001918460018302840111600160201b831117156102ba576000806102b7611963565b50505b91908080601f01602080910402602001604051908101604052818152929190602084018383808284376000920191909152509295949360208101935035915050600160201b81111561031457600080610311611963565b50505b82018360208201111561032f5760008061032c611963565b50505b803590602001918460018302840111600160201b8311171561035957600080610356611963565b50505b91908080601f016020809104026020016040519081016040528181529291906020840183838082843760009201919091525092958435956001600160a01b0360208701351695919450925060608101915060400135600160201b8111156103c8576000806103c5611963565b50505b8201836020820111156103e3576000806103e0611963565b50505b803590602001918460018302840111600160201b8311171561040d5760008061040a611963565b50505b91908080601f0160208091040260200160405190810160405281815292919060208401838380828437600092019190915250929550610e0e945050505050565b005b61015e611165565b60008381868260405160200180838152602001826001600160a01b031660601b815260140192505050604051602081830303815290604052805190602001209050600080836001600160a01b031663838d6e058a89896040516001600160e01b031960e086901b16815260048101939093526001600160a01b039182166024840152166044820152606401604080518083038186806104f46119ce565b15801561050957600080610506611963565b50505b505a610513611a2e565b5050505050158015610532573d6000803e3d600061052f611963565b50505b505050506040513d60408110156105515760008061054e611963565b50505b8101908080519291906020018051955092935060029250610570915050565b82600481111561057c57fe5b14806105935750600382600481111561059157fe5b145b806105a9575060048260048111156105a757fe5b145b6105fc5760405162461bcd60e51b8152602060048201526017602482015276746f6f206561726c79206368616e6e656c20737461746560481b6044820152606401604051809103906105f9611963565b50505b5a610605611b19565b811061065a5760405162461bcd60e51b815260206004820152601760248201527618da185b9b995b081b9bdd081cd95d1d1b1959081e595d604a1b604482015260640160405180910390610657611963565b50505b6000838152600460205260408120905060008060028301610679611b5f565b906101000a90046001600160a01b03166001600160a01b031614156106e55760405162461bcd60e51b81526020600482015260156024820152747265776172645f73656e646572206973207a65726f60581b6044820152606401604051809103906106e2611963565b50505b600060026106f1611b5f565b6001600160a01b036101009290920a90041663beabacc8600060028401610716611b5f565b906101000a90046001600160a01b031683600301600090610735611b5f565b906101000a90046001600160a01b031684600001610751611b5f565b6040516001600160e01b031960e086901b1681526001600160a01b03938416600482015291909216602482015260448101919091526064016020604051808303816000878061079e6119ce565b1580156107b3576000806107b0611963565b50505b505a6107bd611bab565b5050505050501580156107dd573d6000803e3d60006107da611963565b50505b505050506040513d60208110156107fc576000806107f9611963565b50505b81019080805192506108579150505760405162461bcd60e51b81526020600482015260146024820152732aa221903234b2103737ba103a3930b739b332b960611b604482015260640160405180910390610854611963565b50505b83600060038301610866611b5f565b6001600160a01b036101009290920a9004167fe413caa6d70a6d9b51c2af2575a2914490f614355049af8ae7cde5caab9fd201836108a2611b5f565b60405190815260200160405180910390a36000848152600460205260409020600080826108cd611c71565b5050600182016000906108de611c71565b5050600282016001816108ef611b5f565b906001600160a01b0302191690610904611c71565b505060038201600181610915611b5f565b906001600160a01b030219169061092a611c71565b5060019d9c50505050505050505050505050565b600080600161094b611b5f565b906101000a90046001600160a01b03166001600160a01b031663ebc00c05836040516001600160e01b031960e084901b1681526001600160a01b03909116600482015260240160206040518083038186806109a46119ce565b1580156109b9576000806109b6611963565b50505b505a6109c3611a2e565b50505050501580156109e2573d6000803e3d60006109df611963565b50505b505050506040513d6020811015610a01576000806109fe611963565b50505b8101908080519250610a5e9150505760405162461bcd60e51b81526020600482015260166024820152751cd95c9d9a58d9481b9bdd081c9959da5cdd195c995960521b604482015260640160405180910390610a5b611963565b50505b600080876001600160a01b031663838d6e058888886040516001600160e01b031960e086901b16815260048101939093526001600160a01b03918216602484015216604482015260640160408051808303818680610aba6119ce565b158015610acf57600080610acc611963565b50505b505a610ad9611a2e565b5050505050158015610af8573d6000803e3d6000610af5611963565b50505b505050506040513d6040811015610b1757600080610b14611963565b50505b8101908080519291906020018051955092935060029250610b36915050565b826004811115610b4257fe5b14610b915760405162461bcd60e51b815260206004820152601260248201527118da185b9b995b081b9bdd0818db1bdcd95960721b604482015260640160405180910390610b8e611963565b50505b6000886001600160a01b031663b8378f756040518163ffffffff1660e01b81526004016020604051808303818680610bc76119ce565b158015610bdc57600080610bd9611963565b50505b505a610be6611a2e565b5050505050158015610c05573d6000803e3d6000610c02611963565b50505b505050506040513d6020811015610c2457600080610c21611963565b50505b810190808051935050505080821015610c8a5760405162461bcd60e51b815260206004820152601b60248201527a3a37b7903637bb9039b2ba3a363290313637b1b590373ab6b132b960291b604482015260640160405180910390610c87611963565b50505b808203610c9a81838a8a8a610cc7565b9a9950505050505050505050565b60006002610cb4611b5f565b906101000a90046001600160a01b031681565b6000600080516020611d358339815191528510610d335760405162461bcd60e51b815260206004820152601e60248201527f6d616c6963696f75736c792062696720736574746c652074696d656f75740000604482015260640160405180910390610d30611963565b50505b600080516020611d358339815191528610610d9d5760405162461bcd60e51b815260206004820152601f60248201527f6d616c6963696f75736c792062696720636c6f7365645f61745f626c6f636b00604482015260640160405180910390610d9a611963565b50505b601e6050606487830281900489019060328902046000816001600160a01b038a81168a8216019089160181610dce57fe5b06929092019a9950505050505050505050565b60008082610ded6119ce565b15159392505050565b60006001610cb4611b5f565b60006003610cb4611b5f565b610e26828b8b868b5a610e1f611cbf565b8a88611170565b8160006001600160a01b03821663938bcd678d8d6040516001600160e01b031960e085901b1681526001600160a01b039283166004820152911660248201526044016020604051808303818680610e7b6119ce565b158015610e9057600080610e8d611963565b50505b505a610e9a611a2e565b5050505050158015610eb9573d6000803e3d6000610eb6611963565b50505b505050506040513d6020811015610ed857600080610ed5611963565b50505b8101908080519350610efb92508491508390508e8e5a610ef6611cbf565b61093e565b5a610f04611b19565b1015610f585760405162461bcd60e51b81526020600482015260166024820152753737ba1030b63637bbb2b2103a379036b7b734ba37b960511b604482015260640160405180910390610f55611963565b50505b816001600160a01b031663fadc554b828e8e8e8e8e8e8e6040518963ffffffff1660e01b815260040180898152602001886001600160a01b03168152602001876001600160a01b031681526020018681526020018581526020018481526020018060200180602001838103835285818151815260200191508051906020019080838360005b83811015610ff5578082015183820152602001610fdd565b50505050905090810190601f1680156110225780820380516001836020036101000a031916815260200191505b50838103825284818151815260200191508051906020019080838360005b83811015611058578082015183820152602001611040565b50505050905090810190601f1680156110855780820380516001836020036101000a031916815260200191505b509a5050505050505050505050600060405180830381600087806110a76119ce565b1580156110bc576000806110b9611963565b50505b505a6110c6611bab565b5050505050501580156110e6573d6000803e3d60006110e3611963565b50505b505050508a6001600160a01b03165a6110fd611cbf565b6001600160a01b03168a7f486d5933a2980e097e7c32c7fe217158facf1a3973bac8235ac6c8b0e77d3dff87858a60405180846001600160a01b03168152602001838152602001828152602001935050505060405180910390a4505050505050505050505050565b600080610cb4611b5f565b8760006001600160a01b03821663fc0c546a6040518163ffffffff1660e01b815260040160206040518083038186806111a76119ce565b1580156111bc576000806111b9611963565b50505b505a6111c6611a2e565b50505050501580156111e5573d6000803e3d60006111e2611963565b50505b505050506040513d602081101561120457600080611201611963565b50505b810190808051935050506001600160a01b038316905060006003611226611b5f565b906101000a90046001600160a01b03166001600160a01b0316630fabd9e7836040516001600160e01b031960e084901b1681526001600160a01b039091166004820152602401602060405180830381868061127f6119ce565b15801561129457600080611291611963565b50505b505a61129e611a2e565b50505050501580156112bd573d6000803e3d60006112ba611963565b50505b505050506040513d60208110156112dc576000806112d9611963565b50505b8101908080516001600160a01b03169390931492506113449150505760405162461bcd60e51b8152602060048201526014602482015273556e6b6e6f776e20546f6b656e4e6574776f726b60601b604482015260640160405180910390611341611963565b50505b6000826001600160a01b031663938bcd678b8b6040516001600160e01b031960e085901b1681526001600160a01b0392831660048201529116602482015260440160206040518083038186806113986119ce565b1580156113ad576000806113aa611963565b50505b505a6113b7611a2e565b50505050501580156113d6573d6000803e3d60006113d3611963565b50505b505050506040513d60208110156113f5576000806113f2611963565b50505b8101908080519350600092506114ae9150506001600160a01b038516633af973b16040518163ffffffff1660e01b8152600401602060405180830381868061143b6119ce565b1580156114505760008061144d611963565b50505b505a61145a611a2e565b5050505050158015611479573d6000803e3d6000611476611963565b50505b505050506040513d602081101561149857600080611495611963565b50505b81019080805192508f91508d9050898d8a6116a0565b9050896001600160a01b0316816001600160a01b0316146115115760405162461bcd60e51b815260206004820152601060248201526f2130b2103932bbb0b93210383937b7b360811b60448201526064016040518091039061150e611963565b50505b6000828d60405160200180838152602001826001600160a01b031660601b8152601401925050506040516020818303038152906040528051906020012060008181526004602052909150604081209050898160010161156e611b5f565b106115b65760405162461bcd60e51b815260206004820152600b60248201526a7374616c65206e6f6e636560a81b6044820152606401604051809103906115b3611963565b50505b60405180608001604052808c81526020018b81526020018d6001600160a01b031681526020018a6001600160a01b031681525060046000848152602001908152602001600020815181611607611c71565b505060208201518160010161161a611c71565b5050604082015160028201600181611630611b5f565b816001600160a01b0302191690836001600160a01b0316021790611652611c71565b505050606082015160038201600181611669611b5f565b816001600160a01b0302191690836001600160a01b031602179061168b611c71565b50505050505050505050505050505050505050565b6000805a63996d79a5598160e01b8152602081600483336000905af158600e01573d6000803e3d6000fd5b3d6001141558600a015760016000f35b8051925060005b60408110156116f9576000828201526020016116e2565b508a9150600690508989898960405160200180807f19457468657265756d205369676e6564204d6573736167653a0a323231000000815250601d01886001600160a01b031660601b8152601401878152602001868152602001856001600160a01b031660601b8152601401846001600160a01b031660601b815260140183805190602001908083835b602083106117a15780518252601f199092019160209182019101611782565b6001836020036101000a038019825116818451161790925250505091909101928352505060200195506040945050505050516020818303038152906040528051906020012090506117f28184611858565b9150856001600160a01b0316826001600160a01b03161461184d5760405162461bcd60e51b815260040180806020018281038252602f815260200180611d06602f91396040019150506040518091039061184a611963565b50505b509695505050505050565b600081516041146118715760008061186e611963565b50505b60008060006020850151925060408501519150606085015160001a9050601b81101561189b57601b015b8060ff16601b14806118b057508060ff16601c145b6118c2576000806118bf611963565b50505b60018682858560405160008152602001604052604051808581526020018460ff1681526020018381526020018281526020019450505050506020604051602081039080840390855a611912611a2e565b5050505050158015611931573d6000803e3d600061192e611963565b50505b5050506020604051035193506001600160a01b03841661195957600080611956611963565b50505b5050505b92915050565b632a2a7adb598160e01b8152600481016020815285602082015260005b8681101561199b578086015182820160400152602001611980565b506020828760640184336000905af158600e01573d6000803e3d6000fd5b3d6001141558600a015760016000f35b505050565b638435035b598160e01b8152836004820152602081602483336000905af158600e01573d6000803e3d6000fd5b3d6001141558600a015760016000f35b8051935060005b6040811015611a2957600082820152602001611a12565b505050565b638540661f598160e01b8152611a5f565b808083111561195d575090919050565b808083101561195d575090919050565b836004820152846024820152606060448201528660648201526084810160005b88811015611a97578088015182820152602001611a7f565b506060828960a40184336000905af158600e01573d6000803e3d6000fd5b3d6001141558600a015760016000f35b815160408301513d6000853e8b8b82606087013350600060045af15059611aec8d3d611a4f565b8c01611af88187611a3f565b5b82811015611b0d5760008152602001611af9565b50929c50505050505050565b635a98c361598160e01b8152602081600483336000905af158600e01573d6000803e3d6000fd5b3d6001141558600a015760016000f35b80516000825293506020611a12565b6303daa959598160e01b8152836004820152602081602483336000905af158600e01573d6000803e3d6000fd5b3d6001141558600a015760016000f35b80516000825293506020611a12565b6385979f76598160e01b8152836004820152846024820152606060448201528760648201526084810160005b89811015611bef578089015182820152602001611bd7565b506060828a60a40184336000905af158600e01573d6000803e3d6000fd5b3d6001141558600a015760016000f35b815160408301513d6000853e8c8c82606087013350600060045af15059611c448e3d611a4f565b8d01611c508187611a3f565b5b82811015611c655760008152602001611c51565b50929d50505050505050565b6322bd64c0598160e01b8152836004820152846024820152600081604483336000905af158600e01573d6000803e3d6000fd5b3d6001141558600a015760016000f35b600081526020611a12565b6373509064598160e01b8152602081600483336000905af158600e01573d6000803e3d6000fd5b3d6001141558600a015760016000f35b80516000825293506020611a1256fe5265776172642070726f6f6620776974682077726f6e67206e6f6e5f636c6f73696e675f7061727469636970616e74028f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "claimReward(uint256,address,address,address)": {
        "params": {
          "closing_participant": "Address of the participant of the channel that called close",
          "non_closing_participant": "The other participant of the channel",
          "token_network_address": "Address of the Token Network in which the channel exists"
        }
      },
      "constructor": {
        "params": {
          "_service_registry_address": "The address of the ServiceRegistry contract",
          "_token_address": "The address of the token to use for rewards",
          "_token_network_registry_address": "The address of the TokenNetworkRegistry for authenticating TokenNetworks"
        }
      },
      "contractExists(address)": {
        "params": {
          "contract_address": "The address to check whether a contract is deployed or not"
        },
        "returns": {
          "_0": "True if a contract exists, false otherwise"
        }
      },
      "monitor(address,address,bytes32,uint256,bytes32,bytes,bytes,uint256,address,bytes)": {
        "params": {
          "nonce": "Strictly monotonic value used to order BPs omitting PB specific params, since these will not be provided in the future",
          "reward_amount": "Amount of tokens to be rewarded",
          "reward_proof_signature": "The signature of the signed reward proof",
          "token_network_address": "Address of the Token Network in which the channel being monitored exists."
        }
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "claimReward(uint256,address,address,address)": {
        "notice": "Called after a monitored channel is settled in order for MS to claim the reward Can be called once per settled channel by everyone on behalf of MS"
      },
      "constructor": {
        "notice": "Set the default values for the smart contract"
      },
      "contractExists(address)": {
        "notice": "Check if a contract exists"
      },
      "monitor(address,address,bytes32,uint256,bytes32,bytes,bytes,uint256,address,bytes)": {
        "notice": "Called by a registered MS, when providing a new balance proof to a monitored channel. Can be called multiple times by different registered MSs as long as the BP provided is newer than the current newest registered BP."
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 3122,
        "contract": "data/source/services/MonitoringService.sol:MonitoringService",
        "label": "token",
        "offset": 0,
        "slot": "0",
        "type": "t_contract(Token)624"
      },
      {
        "astId": 3124,
        "contract": "data/source/services/MonitoringService.sol:MonitoringService",
        "label": "service_registry",
        "offset": 0,
        "slot": "1",
        "type": "t_contract(ServiceRegistry)4968"
      },
      {
        "astId": 3126,
        "contract": "data/source/services/MonitoringService.sol:MonitoringService",
        "label": "user_deposit",
        "offset": 0,
        "slot": "2",
        "type": "t_contract(UserDeposit)5467"
      },
      {
        "astId": 3128,
        "contract": "data/source/services/MonitoringService.sol:MonitoringService",
        "label": "token_network_registry",
        "offset": 0,
        "slot": "3",
        "type": "t_contract(TokenNetworkRegistry)3087"
      },
      {
        "astId": 3132,
        "contract": "data/source/services/MonitoringService.sol:MonitoringService",
        "label": "rewards",
        "offset": 0,
        "slot": "4",
        "type": "t_mapping(t_bytes32,t_struct(Reward)3141_storage)"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_bytes32": {
        "encoding": "inplace",
        "label": "bytes32",
        "numberOfBytes": "32"
      },
      "t_contract(ServiceRegistry)4968": {
        "encoding": "inplace",
        "label": "contract ServiceRegistry",
        "numberOfBytes": "20"
      },
      "t_contract(Token)624": {
        "encoding": "inplace",
        "label": "contract Token",
        "numberOfBytes": "20"
      },
      "t_contract(TokenNetworkRegistry)3087": {
        "encoding": "inplace",
        "label": "contract TokenNetworkRegistry",
        "numberOfBytes": "20"
      },
      "t_contract(UserDeposit)5467": {
        "encoding": "inplace",
        "label": "contract UserDeposit",
        "numberOfBytes": "20"
      },
      "t_mapping(t_bytes32,t_struct(Reward)3141_storage)": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => struct MonitoringService.Reward)",
        "numberOfBytes": "32",
        "value": "t_struct(Reward)3141_storage"
      },
      "t_struct(Reward)3141_storage": {
        "encoding": "inplace",
        "label": "struct MonitoringService.Reward",
        "members": [
          {
            "astId": 3134,
            "contract": "data/source/services/MonitoringService.sol:MonitoringService",
            "label": "reward_amount",
            "offset": 0,
            "slot": "0",
            "type": "t_uint256"
          },
          {
            "astId": 3136,
            "contract": "data/source/services/MonitoringService.sol:MonitoringService",
            "label": "nonce",
            "offset": 0,
            "slot": "1",
            "type": "t_uint256"
          },
          {
            "astId": 3138,
            "contract": "data/source/services/MonitoringService.sol:MonitoringService",
            "label": "reward_sender_address",
            "offset": 0,
            "slot": "2",
            "type": "t_address"
          },
          {
            "astId": 3140,
            "contract": "data/source/services/MonitoringService.sol:MonitoringService",
            "label": "monitoring_service_address",
            "offset": 0,
            "slot": "3",
            "type": "t_address"
          }
        ],
        "numberOfBytes": "128"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      }
    }
  }
}